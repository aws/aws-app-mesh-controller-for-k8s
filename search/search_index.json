{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AWS App Mesh Controller For K8s \u00b6 AWS App Mesh Controller For K8s is a controller to help manage App Mesh resources for a Kubernetes cluster and injecting sidecars to Kubernetes Pods . The controller watches custom resources for changes and reflects those changes into the App Mesh API . The controller maintains the custom resources ( CRDs ): meshes, virtualnodes, virtualrouters, virtualservices, virtualgateways and gatewayroutes. The custom resources map to App Mesh API objects. Note: For v0.5.0 or older versions of the controller, please refer to legacy-controller branch Security disclosures \u00b6 If you think you\u2019ve found a potential security issue, please do not post it in the Issues. Instead, please follow the instructions here or email AWS security directly . Documentation \u00b6 Checkout our Live Docs !","title":"Home"},{"location":"#aws-app-mesh-controller-for-k8s","text":"AWS App Mesh Controller For K8s is a controller to help manage App Mesh resources for a Kubernetes cluster and injecting sidecars to Kubernetes Pods . The controller watches custom resources for changes and reflects those changes into the App Mesh API . The controller maintains the custom resources ( CRDs ): meshes, virtualnodes, virtualrouters, virtualservices, virtualgateways and gatewayroutes. The custom resources map to App Mesh API objects. Note: For v0.5.0 or older versions of the controller, please refer to legacy-controller branch","title":"AWS App Mesh Controller For K8s"},{"location":"#security-disclosures","text":"If you think you\u2019ve found a potential security issue, please do not post it in the Issues. Instead, please follow the instructions here or email AWS security directly .","title":"Security disclosures"},{"location":"#documentation","text":"Checkout our Live Docs !","title":"Documentation"},{"location":"guide/development/","text":"App Mesh Controller Development Guide \u00b6 Prerequisites \u00b6 Go 1.13+ Docker Make jq Building the Controller \u00b6 The controller Docker image can be built via: AWS_REGION = <region> AWS_ACCOUNT = <account ID> make docker-build This command will compile the controller, run unit tests, and generate a Docker image using the ECR repository format (e.g. <account ID>.dkr.ecr.<region>.amazonaws.com/amazon/appmesh-controller ). The image can be pushed to your local ECR repository via: AWS_REGION = <region> AWS_ACCOUNT = <account ID> make docker-push Once the image has been pushed, you can run the following to install the controller and CRDs to your configured cluster (defined in ~/.kube/config ): AWS_REGION = <region> AWS_ACCOUNT = <account ID> make deploy Building for App Mesh Preview \u00b6 Important : The preview version of the controller will not work against App Mesh's production environment (and vice versa). App Mesh's endpoint and signing name are chosen during the build process. When working against the App Mesh Preview environment, the preview SDK models are downloaded and used to generate the AWS SDK for Go dynamically. The steps for building and deploying the controller are the same as above, but with two new variables for the docker-build step. AWS_REGION = <region> AWS_ACCOUNT = <account ID> APPMESH_SDK_OVERRIDE = y APPMESH_PREVIEW = y make docker-build","title":"Development"},{"location":"guide/development/#app-mesh-controller-development-guide","text":"","title":"App Mesh Controller Development Guide"},{"location":"guide/development/#prerequisites","text":"Go 1.13+ Docker Make jq","title":"Prerequisites"},{"location":"guide/development/#building-the-controller","text":"The controller Docker image can be built via: AWS_REGION = <region> AWS_ACCOUNT = <account ID> make docker-build This command will compile the controller, run unit tests, and generate a Docker image using the ECR repository format (e.g. <account ID>.dkr.ecr.<region>.amazonaws.com/amazon/appmesh-controller ). The image can be pushed to your local ECR repository via: AWS_REGION = <region> AWS_ACCOUNT = <account ID> make docker-push Once the image has been pushed, you can run the following to install the controller and CRDs to your configured cluster (defined in ~/.kube/config ): AWS_REGION = <region> AWS_ACCOUNT = <account ID> make deploy","title":"Building the Controller"},{"location":"guide/development/#building-for-app-mesh-preview","text":"Important : The preview version of the controller will not work against App Mesh's production environment (and vice versa). App Mesh's endpoint and signing name are chosen during the build process. When working against the App Mesh Preview environment, the preview SDK models are downloaded and used to generate the AWS SDK for Go dynamically. The steps for building and deploying the controller are the same as above, but with two new variables for the docker-build step. AWS_REGION = <region> AWS_ACCOUNT = <account ID> APPMESH_SDK_OVERRIDE = y APPMESH_PREVIEW = y make docker-build","title":"Building for App Mesh Preview"},{"location":"guide/installation/","text":"AppMesh Installation Guide \u00b6 Via Helm \u00b6 Follow instructions in appmesh-controller helm chart.","title":"Installation"},{"location":"guide/installation/#appmesh-installation-guide","text":"","title":"AppMesh Installation Guide"},{"location":"guide/installation/#via-helm","text":"Follow instructions in appmesh-controller helm chart.","title":"Via Helm"},{"location":"guide/monitoring/","text":"AppMesh Monitoring Guide \u00b6 AppMesh controller supports monitoring the control plane with Prometheus and Grafana. Install Prometheus \u00b6 Follow instructions in appmesh-prometheus helm chart. Install Grafana \u00b6 Follow instructions in appmesh-grafana helm chart.","title":"Monitoring"},{"location":"guide/monitoring/#appmesh-monitoring-guide","text":"AppMesh controller supports monitoring the control plane with Prometheus and Grafana.","title":"AppMesh Monitoring Guide"},{"location":"guide/monitoring/#install-prometheus","text":"Follow instructions in appmesh-prometheus helm chart.","title":"Install Prometheus"},{"location":"guide/monitoring/#install-grafana","text":"Follow instructions in appmesh-grafana helm chart.","title":"Install Grafana"},{"location":"guide/tracing/","text":"AppMesh Tracing Guide \u00b6 AppMesh controller supports integration with multiple tracing solutions for data plane. AWS X-Ray \u00b6 Enable X-Ray tracing for the App Mesh data plane helm upgrade -i appmesh-controller eks/appmesh-controller \\ --namespace appmesh-system \\ --set tracing.enabled = true \\ --set tracing.provider = x-ray The above configuration will inject the AWS X-Ray daemon sidecar in each pod scheduled to run on the mesh. You can optionally use a specific X-Ray image by setting the following flags in addition to the above: --set xray.image.repository = public.ecr.aws/xray/aws-xray-daemon \\ --set xray.image.tag = 3 .3.3 Note : You should restart all pods running inside the mesh after enabling tracing. Datadog tracing \u00b6 Install the Datadog agent in the appmesh-system namespace Enable Datadog Tracing for the App Mesh data plane helm upgrade -i appmesh-controller eks/appmesh-controller \\ --namespace appmesh-system \\ --set tracing.enabled = true \\ --set tracing.provider = datadog \\ --set tracing.address = datadog.appmesh-system \\ --set tracing.port = 8126 Note : You should restart all pods running inside the mesh after enabling tracing. Jaeger tracing \u00b6 Follow instructions in appmesh-jaeger helm chart. Tips \u00b6 Tracing agents running as DaemonSets \u00b6 For Jaeger and Datadog, running tracing agents as DaemonSets will need the tracing.address set to status.hostIP to use the node's IP. To do this, use the flag below --set tracing.address = ref:status.hostIP","title":"Tracing"},{"location":"guide/tracing/#appmesh-tracing-guide","text":"AppMesh controller supports integration with multiple tracing solutions for data plane.","title":"AppMesh Tracing Guide"},{"location":"guide/tracing/#aws-x-ray","text":"Enable X-Ray tracing for the App Mesh data plane helm upgrade -i appmesh-controller eks/appmesh-controller \\ --namespace appmesh-system \\ --set tracing.enabled = true \\ --set tracing.provider = x-ray The above configuration will inject the AWS X-Ray daemon sidecar in each pod scheduled to run on the mesh. You can optionally use a specific X-Ray image by setting the following flags in addition to the above: --set xray.image.repository = public.ecr.aws/xray/aws-xray-daemon \\ --set xray.image.tag = 3 .3.3 Note : You should restart all pods running inside the mesh after enabling tracing.","title":"AWS X-Ray"},{"location":"guide/tracing/#datadog-tracing","text":"Install the Datadog agent in the appmesh-system namespace Enable Datadog Tracing for the App Mesh data plane helm upgrade -i appmesh-controller eks/appmesh-controller \\ --namespace appmesh-system \\ --set tracing.enabled = true \\ --set tracing.provider = datadog \\ --set tracing.address = datadog.appmesh-system \\ --set tracing.port = 8126 Note : You should restart all pods running inside the mesh after enabling tracing.","title":"Datadog tracing"},{"location":"guide/tracing/#jaeger-tracing","text":"Follow instructions in appmesh-jaeger helm chart.","title":"Jaeger tracing"},{"location":"guide/tracing/#tips","text":"","title":"Tips"},{"location":"guide/tracing/#tracing-agents-running-as-daemonsets","text":"For Jaeger and Datadog, running tracing agents as DaemonSets will need the tracing.address set to status.hostIP to use the node's IP. To do this, use the flag below --set tracing.address = ref:status.hostIP","title":"Tracing agents running as DaemonSets"},{"location":"guide/troubleshooting/","text":"AppMesh Troubleshooting Guide \u00b6 Common Errors \u00b6 Exceeded pod count per VirtualNode/VirtualGateway limit \u00b6 AppMesh limits pod count per virtualNode and virtualGateway. By default the limit is 50. Your can adjust this limit by adjust the \"Connected Envoy processes per virtual node\" service quota . Namespaces is not labeled correctly \u00b6 Namespaces must be labeled with two kind of labels: appmesh.k8s.aws/sidecarInjectorWebhook: enabled is required on namespaces where pod should be injected with envoy sidecars. customized labels to make mesh CustomResource selects the namespace via mesh.spec.namespaceSelector . (optional if you have a single Mesh selects all namespaces) Troubleshooting \u00b6 Tail the controller logs: export APPMESH_SYSTEM_NAMESPACE = appmesh-system kubectl logs -n \" ${ APPMESH_SYSTEM_NAMESPACE } \" -f --since 10s \\ $( kubectl get pods -n \" ${ APPMESH_SYSTEM_NAMESPACE } \" -o name | grep controller ) Tail envoy logs: export APPLICATION_NAMESPACE = <your namespace> export APPLICATION = <your pod or deployment> # i.e. deploy/my-app kubectl logs -n \" ${ APPLICATION_NAMESPACE } \" ${ APPLICATION_POD } \" envoy -f --since 10s View envoy configuration: export APPLICATION_NAMESPACE = <your namespace> export APPLICATION = <your pod> kubectl port-forward -n \" ${ APPLICATION_NAMESPACE } \" \\ $( kubectl get pod -n \" ${ APPLICATION_NAMESPACE } \" | grep \" ${ APPLICATION } \" | awk '{print $1}' ) \\ 9901 Then navigate to localhost:9901/ for the index or localhost:9901/config_dump for the envoy config. VirtualGateway - Common Issues \u00b6 \"failed to find matching virtualGateway for gatewayRoute: gateway-route-headers, expecting 1 but found 0\" The above error message is to inform the user that the GatewayRoute in the error message has not been associated with any VirtualGateway. So the user should either add matching gatewayRouteSelector to the unmatched gatewayRoute or completely remove the gatewayRouteSelector so that the VirtualGateway ignores this field and uses only the namespaceSelector.For more details refer LiveDocs Virtual Gateway section mTLS - Common Issues \u00b6 Envoy fails to boot up when SDS based mTLS is enabled \u00b6 When SDS based mTLS is enabled at the controller level via enable-sds flag, controller expects to find SDS Provider\u2019s UDS at path specified by sds-uds-path . It is set to a default value of /run/spire/sockets/agent.sock which is the default SPIRE Agent\u2019s UDS path. Make sure that SDS Provider on the local node is up and running and UDS is active. Currently, SPIRE is the only supported SDS provider. Please check if SPIRE Agent is up and running on the same node as the problematic Envoy. You can use the below command to figure out the exact reason of the envoy bootup issue. If the error is due to not being able to mount SDS provider's UDS socket then you would need to address that. kubectl describe pod <pod-name> -n <namespace-name> Pod is up and running but Envoy doesn\u2019t have any certs in SDS mode. \u00b6 To begin with, check if APPMESH_SDS_SOCKET_PATH env variable is present under Envoy and if it has the correct UDS path value. If it is missing, then the controller didn\u2019t inject the env variable. Check if enable-sds is set to true for the controller. For example, when using SPIRE Agent you should see something like below in Envoy. APPMESH_SDS_SOCKET_PATH: /run/spire/sockets/agent.sock If the above env variable is present with the correct value, then check if Envoy is able to communicate with the SDS Provider. Below command will help verify if the Envoy is able to reach out to the local SDS Provider via the UDS path passed in to the controller and also to see if it is healthy. kubectl exec -it <pod-name> -n <namespace-name> -c envoy -- curl http://localhost:9901/clusters | grep -E '(static_cluster_sds.*cx_active|static_cluster_sds.*healthy)' static_cluster_sds_unix_socket::/run/spire/sockets/agent.sock::cx_active::1 static_cluster_sds_unix_socket::/run/spire/sockets/agent.sock::health_flags::healthy If the SDS cluster is healthy in Envoy, then check if the workload entry tied to this particular Pod/app container is registered with SPIRE Server and if the selectors match. Use the below command to list out all the registered workload entries. kubectl exec -n spire spire-server-0 -- /opt/spire/bin/spire-server entry show Once you have the list of entries, check for the entry that is tied to the app container and check if the selectors match. Default selectors that we currently use are pod\u2019s service account, namespace and labels. Pod liveness and readiness probes fail when mTLS is enabled \u00b6 HTTP and TCP health checks from the kubelet will not work as is, if mutual TLS is enabled as the kubelet doesn't have relevant certs. Workarounds: Expose the health check endpoint on a different port and skip mTLS for that port. You can then set appmesh.k8s.aws/ports annotation with the application port value on the deployment spec. Example : If your main application port is 8080 and if health check endpoint is exposed on 8081, then appmesh.k8s.aws/ports:8080 will help bypass mTLS for health check port. SDS cluster is present in Envoy's config even though corresponding VirtualNode doesn't have mTLS SDS config \u00b6 Set appmesh.k8s.aws/sds:disabled for the deployments behind VirtualNodes without SDS config.","title":"Troubleshooting"},{"location":"guide/troubleshooting/#appmesh-troubleshooting-guide","text":"","title":"AppMesh Troubleshooting Guide"},{"location":"guide/troubleshooting/#common-errors","text":"","title":"Common Errors"},{"location":"guide/troubleshooting/#exceeded-pod-count-per-virtualnodevirtualgateway-limit","text":"AppMesh limits pod count per virtualNode and virtualGateway. By default the limit is 50. Your can adjust this limit by adjust the \"Connected Envoy processes per virtual node\" service quota .","title":"Exceeded pod count per VirtualNode/VirtualGateway limit"},{"location":"guide/troubleshooting/#namespaces-is-not-labeled-correctly","text":"Namespaces must be labeled with two kind of labels: appmesh.k8s.aws/sidecarInjectorWebhook: enabled is required on namespaces where pod should be injected with envoy sidecars. customized labels to make mesh CustomResource selects the namespace via mesh.spec.namespaceSelector . (optional if you have a single Mesh selects all namespaces)","title":"Namespaces is not labeled correctly"},{"location":"guide/troubleshooting/#troubleshooting","text":"Tail the controller logs: export APPMESH_SYSTEM_NAMESPACE = appmesh-system kubectl logs -n \" ${ APPMESH_SYSTEM_NAMESPACE } \" -f --since 10s \\ $( kubectl get pods -n \" ${ APPMESH_SYSTEM_NAMESPACE } \" -o name | grep controller ) Tail envoy logs: export APPLICATION_NAMESPACE = <your namespace> export APPLICATION = <your pod or deployment> # i.e. deploy/my-app kubectl logs -n \" ${ APPLICATION_NAMESPACE } \" ${ APPLICATION_POD } \" envoy -f --since 10s View envoy configuration: export APPLICATION_NAMESPACE = <your namespace> export APPLICATION = <your pod> kubectl port-forward -n \" ${ APPLICATION_NAMESPACE } \" \\ $( kubectl get pod -n \" ${ APPLICATION_NAMESPACE } \" | grep \" ${ APPLICATION } \" | awk '{print $1}' ) \\ 9901 Then navigate to localhost:9901/ for the index or localhost:9901/config_dump for the envoy config.","title":"Troubleshooting"},{"location":"guide/troubleshooting/#virtualgateway-common-issues","text":"\"failed to find matching virtualGateway for gatewayRoute: gateway-route-headers, expecting 1 but found 0\" The above error message is to inform the user that the GatewayRoute in the error message has not been associated with any VirtualGateway. So the user should either add matching gatewayRouteSelector to the unmatched gatewayRoute or completely remove the gatewayRouteSelector so that the VirtualGateway ignores this field and uses only the namespaceSelector.For more details refer LiveDocs Virtual Gateway section","title":"VirtualGateway - Common Issues"},{"location":"guide/troubleshooting/#mtls-common-issues","text":"","title":"mTLS - Common Issues"},{"location":"guide/troubleshooting/#envoy-fails-to-boot-up-when-sds-based-mtls-is-enabled","text":"When SDS based mTLS is enabled at the controller level via enable-sds flag, controller expects to find SDS Provider\u2019s UDS at path specified by sds-uds-path . It is set to a default value of /run/spire/sockets/agent.sock which is the default SPIRE Agent\u2019s UDS path. Make sure that SDS Provider on the local node is up and running and UDS is active. Currently, SPIRE is the only supported SDS provider. Please check if SPIRE Agent is up and running on the same node as the problematic Envoy. You can use the below command to figure out the exact reason of the envoy bootup issue. If the error is due to not being able to mount SDS provider's UDS socket then you would need to address that. kubectl describe pod <pod-name> -n <namespace-name>","title":"Envoy fails to boot up when SDS based mTLS is enabled"},{"location":"guide/troubleshooting/#pod-is-up-and-running-but-envoy-doesnt-have-any-certs-in-sds-mode","text":"To begin with, check if APPMESH_SDS_SOCKET_PATH env variable is present under Envoy and if it has the correct UDS path value. If it is missing, then the controller didn\u2019t inject the env variable. Check if enable-sds is set to true for the controller. For example, when using SPIRE Agent you should see something like below in Envoy. APPMESH_SDS_SOCKET_PATH: /run/spire/sockets/agent.sock If the above env variable is present with the correct value, then check if Envoy is able to communicate with the SDS Provider. Below command will help verify if the Envoy is able to reach out to the local SDS Provider via the UDS path passed in to the controller and also to see if it is healthy. kubectl exec -it <pod-name> -n <namespace-name> -c envoy -- curl http://localhost:9901/clusters | grep -E '(static_cluster_sds.*cx_active|static_cluster_sds.*healthy)' static_cluster_sds_unix_socket::/run/spire/sockets/agent.sock::cx_active::1 static_cluster_sds_unix_socket::/run/spire/sockets/agent.sock::health_flags::healthy If the SDS cluster is healthy in Envoy, then check if the workload entry tied to this particular Pod/app container is registered with SPIRE Server and if the selectors match. Use the below command to list out all the registered workload entries. kubectl exec -n spire spire-server-0 -- /opt/spire/bin/spire-server entry show Once you have the list of entries, check for the entry that is tied to the app container and check if the selectors match. Default selectors that we currently use are pod\u2019s service account, namespace and labels.","title":"Pod is up and running but Envoy doesn\u2019t have any certs in SDS mode."},{"location":"guide/troubleshooting/#pod-liveness-and-readiness-probes-fail-when-mtls-is-enabled","text":"HTTP and TCP health checks from the kubelet will not work as is, if mutual TLS is enabled as the kubelet doesn't have relevant certs. Workarounds: Expose the health check endpoint on a different port and skip mTLS for that port. You can then set appmesh.k8s.aws/ports annotation with the application port value on the deployment spec. Example : If your main application port is 8080 and if health check endpoint is exposed on 8081, then appmesh.k8s.aws/ports:8080 will help bypass mTLS for health check port.","title":"Pod liveness and readiness probes fail when mTLS is enabled"},{"location":"guide/troubleshooting/#sds-cluster-is-present-in-envoys-config-even-though-corresponding-virtualnode-doesnt-have-mtls-sds-config","text":"Set appmesh.k8s.aws/sds:disabled for the deployments behind VirtualNodes without SDS config.","title":"SDS cluster is present in Envoy's config even though corresponding VirtualNode doesn't have mTLS SDS config"},{"location":"reference/api_design/","text":"AppMesh-K8s integration v1beta2 CRD API design \u00b6 Introduction \u00b6 AppMesh is a service mesh product offered by Amazon. EKS team owns a controller that provides integration between AppMesh and Kubernetes using a custom resource (CRD) API. This document proposes a new version(v1beta2) of CRD API to address issues in current API design(v1beta1). What is the problem \u00b6 There are several issues in the old CRD API model. Details in AppMesh-K8s integration API issues . In summary: The name of Kubernetes resources is tightly coupled with AppMesh names, which is inflexible and confusing. The references between Kubernetes resources is ambiguous and relies on string hacks. The security model for Kubernetes resources is not properly defined. The VirtualNode CRD is implicitly coupled with Deployment resource. The VirtualService cannot directly use VirtualNode as provider Why is it changing \u00b6 We plan to announce k8s AppMesh controller as GA, and we should provide a stable and clean API for better customer experience. Out of scope \u00b6 The detailed implementation of new API is not discussed in this doc. Roles: \u00b6 This document considers two user role: Cluster Administrator: The cluster administrator (ops) is responsible for administration of entire clusters. They manage the lifecycle of AppMesh mesh and provide them to application developers. Application Developer : The application developer (dev) is responsible for defining their application configuration and service composition. Use cases: \u00b6 As a Cluster Administrator for multi-tenant EKS cluster, I should be able to allocate a service mesh and control which users can create resources in this mesh. As an Application Developer, I should be able to define the service routing logic and backend configuration for my application without Cluster Administrator's intervention. Tenets: \u00b6 The API should follow Kubernetes API conventions The API should be unambiguous, there should be only one obvious way for given task The API should be explicit instead of rely on implicit logic The API should be simple for 99% use case The API should be open for future extensions Design \u00b6 API overview \u00b6 We\u2019ll use four CRD to represent AppMesh objects: Mesh: Represents an AppMesh mesh object. VirtualNode: Represents an AppMesh virtualNode object. VirtualService: Represents an AppMesh virtualService object, which can use either VirtualRouter or VirtualNode as provider. VirtualRouter: Represents an AppMesh virtualRouter object and embeds virtualRoute. Detailed changes are discussed below: Decouple k8s resource name from AppMesh resource name \u00b6 Resource names for k8s resources should be decoupled from appMesh resource names. Users should be able to freely denote the resource name for k8s resources independently from appMesh resource names. Sensible default for appMesh resource names can be derived from k8s resource name . Mesh resource have a field \u201c awsName \u201d to denote the AppMesh name for mesh. It defaults to be same as the name of mesh k8s resource. Note: we may consider use other field name like \u201cmeshName\u201d, \u201cawsMeshName\u201d. we choose \u201cawsName\u201d over simply \u201cname\u201d to avoid confusing. This enables use cases like use same resource name(e.g. \u201c global \u201d) for the k8s Mesh resource in different EKS clusters, while maps to different appMesh name. apiVersion : appmesh.k8s.aws/v1beta2 kind : Mesh metadata : name : global spec : awsName : my-cluster-mesh VirtualService resource have a field \u201c awsName \u201d to denote the AppMesh name for VirtualService. It defaults to be \"$name.$namespace\" of VirtualService k8s resource. Note: the controller is responsible for detecting conflicting awsName with a mesh and report errors . apiVersion : appmesh.k8s.aws/v1beta2 kind : VirtualService metadata : namespace : my-app-ns name : svc-a spec : awsName : svc-a.my-app-ns Alternative designs considered: Enforce bind appMesh virtualServiceName to be VirtualService resource\u2019s name. ( this is existing design used in our controller ) apiVersion : appmesh.k8s.aws/v1beta1 kind : VirtualService metadata : namespace : my-app-ns name : my-app-node.my-app-ns.svc.cluster.local spec : ... Pros: * the k8s namespace serves as a scope as a weak guarantee for uniqueness of hostNames. (it\u2019s weak guarantee since there can still be possible hostName conflicts for resources in multiple namespaces) Cons: * harder to extend to multiple hostName support * name of k8s resource tied to appMesh name have an array field \u201c hosts \u201d to denote the AppMesh names for VirtualService For each host, we\u2019ll transparently create an appMesh VirtualService object . It defaults to have single entry of the VirtualService resource\u2019s name. apiVersion : appmesh.k8s.aws/v1beta2 kind : VirtualService metadata : namespace : my-app-ns name : my-app-svc spec : hosts : - my-app-svc.my-app-ns - my-app-svc.my-app-ns.svc.cluster.local Pros: * user friendly if multiple hostname for a service is desired. (under k8s, a pod can use multiple name to contact a service with the help of DNS search list). Cons: * not align with AppMesh API. (we decided not to do this unless appMesh itself supports such API). VirtualNode resource can have a field \u201c awsName \u201d to denote the AppMesh name for VirtualNode. It defaults to be \u201c ${name}_${namespace} \u201d of the VirtualNode resource. Note: we may consider use other field name like \u201cvirtualNodeName\u201d, \u201cawsVirtualNodeName\u201d. we choose \u201cawsName\u201d over simply \u201cname\u201d to avoid confusing. Note: currently controller use \"-\" as separator when build name, but we plan to change it to \"_\" to avoid conflicts with k8s's naming restrictions . This enables use cases like have different app mesh VirtualNode under different context. e.g. for a mesh designated for a single EKS cluster, the default can be \u201c ${name}_${namespace} \u201d. And for a mesh designated to be shared by multiple EKS clusters, the default can be \u201c ${name} ${namespace} ${clusterName} \u201d. The naming pattern can be controlled by immutable attributes on mesh resource in the future(e.g. spec.multiCluster ) apiVersion : appmesh.k8s.aws/v1beta2 kind : VirtualNode metadata : namespace : my-app-ns name : node-v1 spec : awsName : node-v1_my-app-ns Use typed references to reference resources within cluster \u00b6 we can use typed reference for relationship between resources within cluster. use virtualNodeRef for reference from VirtualRouter to VirtualNode apiVersion : appmesh.k8s.aws/v1beta2 kind : VirtualRouter metadata : namespace : my-app-ns name : svc-a spec : awsName : svc-a_my-app-ns listeners : - portMapping : port : 9080 protocol : http routes : - name : route-to-auth http : match : prefix : /auth action : weightedTargets : - virtualNodeRef : namespace : my-app-ns # can be omitted if in same namespace as VirtualRouter name : node-v1 weight : 1 Alternative designs considered: use mangled name of k8s virtualNode resource. ( this is existing design used in our controller ) We can use a mangled name of virtualNode resource. like \u201c ${nodeName} \u201d when referencing a virtualNode within current namespace and \u201c ${nodeName}.${namespace} \u201d when referencing a virtualNode in another namespace. weightedTargets : - virtualNodeName : colorteller.appmesh-demo weight : 4 - virtualNodeName : colorteller-blue weight : 3 - virtualNodeName : colorteller-black.appmesh-demo weight : 3 Cons: * VirtualNodeName here is ambiguous. It\u2019s referencing the name of k8s VirtualNode instead of appMesh VirtualNode. * It string hacks by whether there is a \u201c.\u201d inside and use it as name/namespace separator. while \u201c.\u2018 is valid to be part of name identifier in k8s. * It cannot be extended to support reference external virtualNode in mesh (like a ECS node) use the real name of appMesh virtualNode. We can use the real name of appMesh virtualNode instead of mangled name of k8s object. The above example will be: weightedTargets : - virtualNodeName : colorteller_appmesh-demo weight : 4 - virtualNodeName : colorteller-blue weight : 3 - virtualNodeName : colorteller-black_appmesh-demo weight : 3 Pros: * unambiguous supported both virtualNode in k8s and external like ECS. * simple implementation Cons: * users need to be aware of the name pattern of appMesh objects when want to reference a virtualNode created within cluster. however, it\u2019s subject to change, e.g. we may include a cluster identifier in appMesh name as well if we plan to support multiple cluster. * not k8s native for reference between objects [ optional, not planned ] virtualNodeRef can be extended to support resources outside of k8s cluster. e.g. a ECS virtual node. Note: we using field like \u201cawsName\u201d instead of \u201cvirtualNodeName\u201d to avoid confusing, since \u201cvirtualNodeName\u201d means \u201cname for a k8s virtualNode resource\u201d under k8s\u2019s convention. ```yaml apiVersion: appmesh.k8s.aws/v1beta2 kind: VirtualRouter metadata: namespace: my-app-ns name: svc-a spec: awsName: svc-a_my-app-ns listeners: - portMapping: port: 9080 protocol: http routes: - name: route-to-auth http: match: prefix: /auth action: weightedTargets: - virtualNodeRef: awsName: my-ecs-node weight: 1 1. use virtualServiceRef for references from VirtualNode to VirtualService apiVersion : appmesh.k8s.aws/v1beta1 kind : VirtualNode metadata : namespace : my-app-ns name : my-app-node spec : ...other fileds... backends : - virtualService : virtualServiceRef : namespace : my-app-ns # can be omitted if in same namespace as VirtualNode name : my-app-svc Alternative designs considered: use the real name of appMesh virtualService. ( this is existing design used in our controller ) We can use the real name of appMesh virtualService when referencing it in nodes. Pros: * unambiguous supported both virtualService in k8s and external like ECS. * simple implementation Cons: * not k8s native for reference between objects * not consistent with how we reference nodes from services. [ optional, not planned ] virtualServiceRef can be extended to support resources outside of k8s cluster. e.g. a ECS virtual service. Note: we are using field like \u201cawsName\u201d instead of \u201cvirtualServiceName\u201d to avoid confusing, since \u201cvirtualServiceName\u201d means \u201cname for a k8s virtualService resource\u201d under k8s\u2019s convention. apiVersion : appmesh.k8s.aws/v1beta1 kind : VirtualNode metadata : namespace : my-app-ns name : my-app-node spec : ...other fields... backends : - virtualService : virtualServiceRef : awsName : \"my-ecs-service\" Decouple VirtualRouter from VirtualService \u00b6 In AppMesh a VirtualService can use either VirtualRouter or VirtualNode as provider. VirtualRouter is only need when L7 routing functionality is needed. We\u2019ll create a new CRD named VirtualRouter , which represents AppMesh VirtualRouter object and embeds multiple AppMesh VirtualRoute objects. apiVersion : appmesh.k8s.aws/v1beta2 kind : VirtualRouter metadata : namespace : my-app-ns name : svc-a spec : awsName : svc-a_my-app-ns listeners : - portMapping : port : 9080 protocol : http routes : - name : route-to-auth http : match : prefix : /auth action : weightedTargets : - virtualNodeRef : namespace : my-app-ns name : node-v1 weight : 1 Note: The additional hierarchy of \"virtualRouter\" and \"virtualNode\" in addition to \"virtualRouterRef\" and \"virtualNodeRef\" is to align with AppMesh API(so that additional attributes specific to provider can be added easily). VirtualService can reference virtualRouter as provider: apiVersion : appmesh.k8s.aws/v1beta2 kind : VirtualService metadata : namespace : my-app-ns name : svc-a spec : hosts : - svc-b.my-app-ns.svc.cluster.local provider : virtualRouter : virtualRouterRef : namespace : my-app-ns name : svc-a-router VirtualService can reference virtualNode as provider: apiVersion : appmesh.k8s.aws/v1beta2 kind : VirtualService metadata : namespace : my-app-ns name : svc-b spec : hosts : - svc-a.my-app-ns.svc.cluster.local provider : virtualNode : virtualNodeRef : namespace : my-app-ns name : node-v2 Use selector on Mesh to denote mesh membership for resources within namespaces \u00b6 Meshes should be set up by cluster administrator, they can use a selector to designate the mesh membership for resources in different k8s namespaces. Note: The label selectors of two mesh must not overlap. Controller should error if detected conflicting meshes for given resource. Initially, we can assume all resources in a single namespace will always belong to same mesh, so we only need namespaceSelector on Mesh resource. namespaceSelector follows standard label selector semantics, if presents not empty, it selects all namespaces. This also enables use cases like share a AppMesh application configuration since the application specific configuration(virtualNode / virtualService) no longer rely on specific mesh presents. apiVersion : appmesh.k8s.aws/v1beta2 kind : Mesh metadata : name : global spec : namespaceSelector : matchLabels : mesh : my-mesh --- apiVersion : v1 kind : Namespace metadata : name : my-app-ns labels : mesh : my-mesh [ optional, not planned ] If we need to support resources in a single namespace to belong to different meshes, we can extend above to have a resourceSelector to match labels on resources like VirtualService and VirtualNode in addition to the namespaceSelector. apiVersion : appmesh.k8s.aws/v1beta2 kind : Mesh metadata : name : my-mesh spec : namespaceSelector : matchLabels : mesh : my-mesh resourceSelector : matchLabels : mesh : my-mesh Alternative designs considered: 1. Use meshName on resources to denote mesh membership. ( this is existing design used in our controller ) Currently we are using a meshName on resources to denote mesh membership . ``` yaml apiVersion : appmesh . k8s . aws / v1beta1 kind : VirtualService metadata : namespace : my - app - ns name : my - app - svc spec : meshName : my - mesh ... other fields ... ``` Pros : * enforced that a resource can only belong to a single mesh . * simple implementation for lookup mesh based on resource . since the meshName is included on resources directly . Cons : * poor security model . a less privileged user limited within namespace can create resources into mesh freely . * requires user to set meshName on every resource even within a namespace . Use annotation on namespaces to denote mesh membership. We can use annotations on namespaces to denote mesh membership. apiVersion : v1 kind : Namespace metadata : name : my-app-ns annotations : appmesh.k8s.aws/mesh-name : my-mesh Pros: * enforced that a resource in a namespace can only belong to a single mesh * simple implementation for lookup mesh based on resource. since the meshName is included on resources\u2019s namespace directly. Cons: * not Kubernetes native. The Kubernetes native way is to use label selector to denote membership. * not possible for extensions like for a single namespace into multiple meshes in the future. Use an array of selectors instead of a single one on mesh resource. Selectors among selectors array are \u201c OR \u201d relationship. And within a selector it\u2019s AND relationship(e.g. resources must match both namespaceSelector & resourceSelector to be member of the mesh) apiVersion : appmesh.k8s.aws/v1beta2 kind : Mesh metadata : name : my-mesh spec : selectors : - namespaceSelector : matchLabels : mesh : my-mesh - namespaceSelector : matchLabels : my-mesh : \"true\" resourceSelector : matchLabels : my-mesh : \"true\" Pros: * let user freely define selectors for different use cases. Cons: * over complicated for simple use cases. users should be properly organize their labels to achieve similar effect even under the single selector proposal. Use selector on VirtualNode to denote node membership \u00b6 We use a podSelector to match pods that should be member of virtualNode. Note, we don\u2019t use a namespace selector here since we want to enforce pods are in same namespace of virtualNode resource. The label selectors of two virtualNode within namespace must not overlap. Controller should error if detected conflicting virtualNode for given pod. The injector will be changed to work using following logic: 1. for each pod created, it match against all virtualNode\u2019s selector within namespace. 2. If it finds a single match, injects according to virtualNode\u2019s mesh and name. 3. If it finds multiple match, it reports error. 4. The global \" APPMESH_NAME \" environment variable on injector deployment and annotation \" appmesh.k8s.aws/mesh \" and \" appmesh.k8s.aws/virtualNode \" annotation on pod will no longer be supported. apiVersion : appmesh.k8s.aws/v1beta1 kind : VirtualNode metadata : namespace : my-app-ns name : my-app-node spec : ...other fields... podSelector : matchLabels : app : my-app-node --- apiVersion : apps/v1 kind : Deployment metadata : namespace : my-app-ns name : my-app-node-deployment spec : selector : matchLabels : app : my-app-node replicas : 5 template : metadata : labels : app : my-app-node spec : containers : - name : app image : awesomeimage:v1.0.0 ports : - containerPort : 80 Alternative designs considered: The injector use an environment variable for default mesh name and allow override per pod with annotation appmesh.k8s.aws/mesh . Also, the virtualNodeName is derived from pod\u2019s replicaSet\u2019s deployment name and allows override per pod with annotation appmesh.k8s.aws/virtualNode ( this is existing design used in our controller ) Pros: * easy to implement since all information is on pod itself. Cons: * The default behavior to resolve mesh relies on the fact that there is only one mesh in cluster, which conflicts with our multiple mesh per cluster support. * The default behavior to resolve virtualNode is not k8s native. it implies pods are managed by replicaSets then by deployments, which is tricky and not always true. * the annotations are intrusive to user\u2019s application.","title":"APIDesign"},{"location":"reference/api_design/#appmesh-k8s-integration-v1beta2-crd-api-design","text":"","title":"AppMesh-K8s integration v1beta2 CRD API design"},{"location":"reference/api_design/#introduction","text":"AppMesh is a service mesh product offered by Amazon. EKS team owns a controller that provides integration between AppMesh and Kubernetes using a custom resource (CRD) API. This document proposes a new version(v1beta2) of CRD API to address issues in current API design(v1beta1).","title":"Introduction"},{"location":"reference/api_design/#what-is-the-problem","text":"There are several issues in the old CRD API model. Details in AppMesh-K8s integration API issues . In summary: The name of Kubernetes resources is tightly coupled with AppMesh names, which is inflexible and confusing. The references between Kubernetes resources is ambiguous and relies on string hacks. The security model for Kubernetes resources is not properly defined. The VirtualNode CRD is implicitly coupled with Deployment resource. The VirtualService cannot directly use VirtualNode as provider","title":"What is the problem"},{"location":"reference/api_design/#why-is-it-changing","text":"We plan to announce k8s AppMesh controller as GA, and we should provide a stable and clean API for better customer experience.","title":"Why is it changing"},{"location":"reference/api_design/#out-of-scope","text":"The detailed implementation of new API is not discussed in this doc.","title":"Out of scope"},{"location":"reference/api_design/#roles","text":"This document considers two user role: Cluster Administrator: The cluster administrator (ops) is responsible for administration of entire clusters. They manage the lifecycle of AppMesh mesh and provide them to application developers. Application Developer : The application developer (dev) is responsible for defining their application configuration and service composition.","title":"Roles:"},{"location":"reference/api_design/#use-cases","text":"As a Cluster Administrator for multi-tenant EKS cluster, I should be able to allocate a service mesh and control which users can create resources in this mesh. As an Application Developer, I should be able to define the service routing logic and backend configuration for my application without Cluster Administrator's intervention.","title":"Use cases:"},{"location":"reference/api_design/#tenets","text":"The API should follow Kubernetes API conventions The API should be unambiguous, there should be only one obvious way for given task The API should be explicit instead of rely on implicit logic The API should be simple for 99% use case The API should be open for future extensions","title":"Tenets:"},{"location":"reference/api_design/#design","text":"","title":"Design"},{"location":"reference/api_design/#api-overview","text":"We\u2019ll use four CRD to represent AppMesh objects: Mesh: Represents an AppMesh mesh object. VirtualNode: Represents an AppMesh virtualNode object. VirtualService: Represents an AppMesh virtualService object, which can use either VirtualRouter or VirtualNode as provider. VirtualRouter: Represents an AppMesh virtualRouter object and embeds virtualRoute. Detailed changes are discussed below:","title":"API overview"},{"location":"reference/api_design/#decouple-k8s-resource-name-from-appmesh-resource-name","text":"Resource names for k8s resources should be decoupled from appMesh resource names. Users should be able to freely denote the resource name for k8s resources independently from appMesh resource names. Sensible default for appMesh resource names can be derived from k8s resource name . Mesh resource have a field \u201c awsName \u201d to denote the AppMesh name for mesh. It defaults to be same as the name of mesh k8s resource. Note: we may consider use other field name like \u201cmeshName\u201d, \u201cawsMeshName\u201d. we choose \u201cawsName\u201d over simply \u201cname\u201d to avoid confusing. This enables use cases like use same resource name(e.g. \u201c global \u201d) for the k8s Mesh resource in different EKS clusters, while maps to different appMesh name. apiVersion : appmesh.k8s.aws/v1beta2 kind : Mesh metadata : name : global spec : awsName : my-cluster-mesh VirtualService resource have a field \u201c awsName \u201d to denote the AppMesh name for VirtualService. It defaults to be \"$name.$namespace\" of VirtualService k8s resource. Note: the controller is responsible for detecting conflicting awsName with a mesh and report errors . apiVersion : appmesh.k8s.aws/v1beta2 kind : VirtualService metadata : namespace : my-app-ns name : svc-a spec : awsName : svc-a.my-app-ns Alternative designs considered: Enforce bind appMesh virtualServiceName to be VirtualService resource\u2019s name. ( this is existing design used in our controller ) apiVersion : appmesh.k8s.aws/v1beta1 kind : VirtualService metadata : namespace : my-app-ns name : my-app-node.my-app-ns.svc.cluster.local spec : ... Pros: * the k8s namespace serves as a scope as a weak guarantee for uniqueness of hostNames. (it\u2019s weak guarantee since there can still be possible hostName conflicts for resources in multiple namespaces) Cons: * harder to extend to multiple hostName support * name of k8s resource tied to appMesh name have an array field \u201c hosts \u201d to denote the AppMesh names for VirtualService For each host, we\u2019ll transparently create an appMesh VirtualService object . It defaults to have single entry of the VirtualService resource\u2019s name. apiVersion : appmesh.k8s.aws/v1beta2 kind : VirtualService metadata : namespace : my-app-ns name : my-app-svc spec : hosts : - my-app-svc.my-app-ns - my-app-svc.my-app-ns.svc.cluster.local Pros: * user friendly if multiple hostname for a service is desired. (under k8s, a pod can use multiple name to contact a service with the help of DNS search list). Cons: * not align with AppMesh API. (we decided not to do this unless appMesh itself supports such API). VirtualNode resource can have a field \u201c awsName \u201d to denote the AppMesh name for VirtualNode. It defaults to be \u201c ${name}_${namespace} \u201d of the VirtualNode resource. Note: we may consider use other field name like \u201cvirtualNodeName\u201d, \u201cawsVirtualNodeName\u201d. we choose \u201cawsName\u201d over simply \u201cname\u201d to avoid confusing. Note: currently controller use \"-\" as separator when build name, but we plan to change it to \"_\" to avoid conflicts with k8s's naming restrictions . This enables use cases like have different app mesh VirtualNode under different context. e.g. for a mesh designated for a single EKS cluster, the default can be \u201c ${name}_${namespace} \u201d. And for a mesh designated to be shared by multiple EKS clusters, the default can be \u201c ${name} ${namespace} ${clusterName} \u201d. The naming pattern can be controlled by immutable attributes on mesh resource in the future(e.g. spec.multiCluster ) apiVersion : appmesh.k8s.aws/v1beta2 kind : VirtualNode metadata : namespace : my-app-ns name : node-v1 spec : awsName : node-v1_my-app-ns","title":"Decouple k8s resource name from AppMesh resource name"},{"location":"reference/api_design/#use-typed-references-to-reference-resources-within-cluster","text":"we can use typed reference for relationship between resources within cluster. use virtualNodeRef for reference from VirtualRouter to VirtualNode apiVersion : appmesh.k8s.aws/v1beta2 kind : VirtualRouter metadata : namespace : my-app-ns name : svc-a spec : awsName : svc-a_my-app-ns listeners : - portMapping : port : 9080 protocol : http routes : - name : route-to-auth http : match : prefix : /auth action : weightedTargets : - virtualNodeRef : namespace : my-app-ns # can be omitted if in same namespace as VirtualRouter name : node-v1 weight : 1 Alternative designs considered: use mangled name of k8s virtualNode resource. ( this is existing design used in our controller ) We can use a mangled name of virtualNode resource. like \u201c ${nodeName} \u201d when referencing a virtualNode within current namespace and \u201c ${nodeName}.${namespace} \u201d when referencing a virtualNode in another namespace. weightedTargets : - virtualNodeName : colorteller.appmesh-demo weight : 4 - virtualNodeName : colorteller-blue weight : 3 - virtualNodeName : colorteller-black.appmesh-demo weight : 3 Cons: * VirtualNodeName here is ambiguous. It\u2019s referencing the name of k8s VirtualNode instead of appMesh VirtualNode. * It string hacks by whether there is a \u201c.\u201d inside and use it as name/namespace separator. while \u201c.\u2018 is valid to be part of name identifier in k8s. * It cannot be extended to support reference external virtualNode in mesh (like a ECS node) use the real name of appMesh virtualNode. We can use the real name of appMesh virtualNode instead of mangled name of k8s object. The above example will be: weightedTargets : - virtualNodeName : colorteller_appmesh-demo weight : 4 - virtualNodeName : colorteller-blue weight : 3 - virtualNodeName : colorteller-black_appmesh-demo weight : 3 Pros: * unambiguous supported both virtualNode in k8s and external like ECS. * simple implementation Cons: * users need to be aware of the name pattern of appMesh objects when want to reference a virtualNode created within cluster. however, it\u2019s subject to change, e.g. we may include a cluster identifier in appMesh name as well if we plan to support multiple cluster. * not k8s native for reference between objects [ optional, not planned ] virtualNodeRef can be extended to support resources outside of k8s cluster. e.g. a ECS virtual node. Note: we using field like \u201cawsName\u201d instead of \u201cvirtualNodeName\u201d to avoid confusing, since \u201cvirtualNodeName\u201d means \u201cname for a k8s virtualNode resource\u201d under k8s\u2019s convention. ```yaml apiVersion: appmesh.k8s.aws/v1beta2 kind: VirtualRouter metadata: namespace: my-app-ns name: svc-a spec: awsName: svc-a_my-app-ns listeners: - portMapping: port: 9080 protocol: http routes: - name: route-to-auth http: match: prefix: /auth action: weightedTargets: - virtualNodeRef: awsName: my-ecs-node weight: 1 1. use virtualServiceRef for references from VirtualNode to VirtualService apiVersion : appmesh.k8s.aws/v1beta1 kind : VirtualNode metadata : namespace : my-app-ns name : my-app-node spec : ...other fileds... backends : - virtualService : virtualServiceRef : namespace : my-app-ns # can be omitted if in same namespace as VirtualNode name : my-app-svc Alternative designs considered: use the real name of appMesh virtualService. ( this is existing design used in our controller ) We can use the real name of appMesh virtualService when referencing it in nodes. Pros: * unambiguous supported both virtualService in k8s and external like ECS. * simple implementation Cons: * not k8s native for reference between objects * not consistent with how we reference nodes from services. [ optional, not planned ] virtualServiceRef can be extended to support resources outside of k8s cluster. e.g. a ECS virtual service. Note: we are using field like \u201cawsName\u201d instead of \u201cvirtualServiceName\u201d to avoid confusing, since \u201cvirtualServiceName\u201d means \u201cname for a k8s virtualService resource\u201d under k8s\u2019s convention. apiVersion : appmesh.k8s.aws/v1beta1 kind : VirtualNode metadata : namespace : my-app-ns name : my-app-node spec : ...other fields... backends : - virtualService : virtualServiceRef : awsName : \"my-ecs-service\"","title":"Use typed references to reference resources within cluster"},{"location":"reference/api_design/#decouple-virtualrouter-from-virtualservice","text":"In AppMesh a VirtualService can use either VirtualRouter or VirtualNode as provider. VirtualRouter is only need when L7 routing functionality is needed. We\u2019ll create a new CRD named VirtualRouter , which represents AppMesh VirtualRouter object and embeds multiple AppMesh VirtualRoute objects. apiVersion : appmesh.k8s.aws/v1beta2 kind : VirtualRouter metadata : namespace : my-app-ns name : svc-a spec : awsName : svc-a_my-app-ns listeners : - portMapping : port : 9080 protocol : http routes : - name : route-to-auth http : match : prefix : /auth action : weightedTargets : - virtualNodeRef : namespace : my-app-ns name : node-v1 weight : 1 Note: The additional hierarchy of \"virtualRouter\" and \"virtualNode\" in addition to \"virtualRouterRef\" and \"virtualNodeRef\" is to align with AppMesh API(so that additional attributes specific to provider can be added easily). VirtualService can reference virtualRouter as provider: apiVersion : appmesh.k8s.aws/v1beta2 kind : VirtualService metadata : namespace : my-app-ns name : svc-a spec : hosts : - svc-b.my-app-ns.svc.cluster.local provider : virtualRouter : virtualRouterRef : namespace : my-app-ns name : svc-a-router VirtualService can reference virtualNode as provider: apiVersion : appmesh.k8s.aws/v1beta2 kind : VirtualService metadata : namespace : my-app-ns name : svc-b spec : hosts : - svc-a.my-app-ns.svc.cluster.local provider : virtualNode : virtualNodeRef : namespace : my-app-ns name : node-v2","title":"Decouple VirtualRouter from VirtualService"},{"location":"reference/api_design/#use-selector-on-mesh-to-denote-mesh-membership-for-resources-within-namespaces","text":"Meshes should be set up by cluster administrator, they can use a selector to designate the mesh membership for resources in different k8s namespaces. Note: The label selectors of two mesh must not overlap. Controller should error if detected conflicting meshes for given resource. Initially, we can assume all resources in a single namespace will always belong to same mesh, so we only need namespaceSelector on Mesh resource. namespaceSelector follows standard label selector semantics, if presents not empty, it selects all namespaces. This also enables use cases like share a AppMesh application configuration since the application specific configuration(virtualNode / virtualService) no longer rely on specific mesh presents. apiVersion : appmesh.k8s.aws/v1beta2 kind : Mesh metadata : name : global spec : namespaceSelector : matchLabels : mesh : my-mesh --- apiVersion : v1 kind : Namespace metadata : name : my-app-ns labels : mesh : my-mesh [ optional, not planned ] If we need to support resources in a single namespace to belong to different meshes, we can extend above to have a resourceSelector to match labels on resources like VirtualService and VirtualNode in addition to the namespaceSelector. apiVersion : appmesh.k8s.aws/v1beta2 kind : Mesh metadata : name : my-mesh spec : namespaceSelector : matchLabels : mesh : my-mesh resourceSelector : matchLabels : mesh : my-mesh Alternative designs considered: 1. Use meshName on resources to denote mesh membership. ( this is existing design used in our controller ) Currently we are using a meshName on resources to denote mesh membership . ``` yaml apiVersion : appmesh . k8s . aws / v1beta1 kind : VirtualService metadata : namespace : my - app - ns name : my - app - svc spec : meshName : my - mesh ... other fields ... ``` Pros : * enforced that a resource can only belong to a single mesh . * simple implementation for lookup mesh based on resource . since the meshName is included on resources directly . Cons : * poor security model . a less privileged user limited within namespace can create resources into mesh freely . * requires user to set meshName on every resource even within a namespace . Use annotation on namespaces to denote mesh membership. We can use annotations on namespaces to denote mesh membership. apiVersion : v1 kind : Namespace metadata : name : my-app-ns annotations : appmesh.k8s.aws/mesh-name : my-mesh Pros: * enforced that a resource in a namespace can only belong to a single mesh * simple implementation for lookup mesh based on resource. since the meshName is included on resources\u2019s namespace directly. Cons: * not Kubernetes native. The Kubernetes native way is to use label selector to denote membership. * not possible for extensions like for a single namespace into multiple meshes in the future. Use an array of selectors instead of a single one on mesh resource. Selectors among selectors array are \u201c OR \u201d relationship. And within a selector it\u2019s AND relationship(e.g. resources must match both namespaceSelector & resourceSelector to be member of the mesh) apiVersion : appmesh.k8s.aws/v1beta2 kind : Mesh metadata : name : my-mesh spec : selectors : - namespaceSelector : matchLabels : mesh : my-mesh - namespaceSelector : matchLabels : my-mesh : \"true\" resourceSelector : matchLabels : my-mesh : \"true\" Pros: * let user freely define selectors for different use cases. Cons: * over complicated for simple use cases. users should be properly organize their labels to achieve similar effect even under the single selector proposal.","title":"Use selector on Mesh to denote mesh membership for resources within namespaces"},{"location":"reference/api_design/#use-selector-on-virtualnode-to-denote-node-membership","text":"We use a podSelector to match pods that should be member of virtualNode. Note, we don\u2019t use a namespace selector here since we want to enforce pods are in same namespace of virtualNode resource. The label selectors of two virtualNode within namespace must not overlap. Controller should error if detected conflicting virtualNode for given pod. The injector will be changed to work using following logic: 1. for each pod created, it match against all virtualNode\u2019s selector within namespace. 2. If it finds a single match, injects according to virtualNode\u2019s mesh and name. 3. If it finds multiple match, it reports error. 4. The global \" APPMESH_NAME \" environment variable on injector deployment and annotation \" appmesh.k8s.aws/mesh \" and \" appmesh.k8s.aws/virtualNode \" annotation on pod will no longer be supported. apiVersion : appmesh.k8s.aws/v1beta1 kind : VirtualNode metadata : namespace : my-app-ns name : my-app-node spec : ...other fields... podSelector : matchLabels : app : my-app-node --- apiVersion : apps/v1 kind : Deployment metadata : namespace : my-app-ns name : my-app-node-deployment spec : selector : matchLabels : app : my-app-node replicas : 5 template : metadata : labels : app : my-app-node spec : containers : - name : app image : awesomeimage:v1.0.0 ports : - containerPort : 80 Alternative designs considered: The injector use an environment variable for default mesh name and allow override per pod with annotation appmesh.k8s.aws/mesh . Also, the virtualNodeName is derived from pod\u2019s replicaSet\u2019s deployment name and allows override per pod with annotation appmesh.k8s.aws/virtualNode ( this is existing design used in our controller ) Pros: * easy to implement since all information is on pod itself. Cons: * The default behavior to resolve mesh relies on the fact that there is only one mesh in cluster, which conflicts with our multiple mesh per cluster support. * The default behavior to resolve virtualNode is not k8s native. it implies pods are managed by replicaSets then by deployments, which is tricky and not always true. * the annotations are intrusive to user\u2019s application.","title":"Use selector on VirtualNode to denote node membership"},{"location":"reference/api_spec/","text":"Packages: appmesh.k8s.aws/v1beta2 appmesh.k8s.aws/v1beta2 Package v1beta2 contains API Schema definitions for the appmesh v1beta2 API group Resource Types: AWSCloudMapInstanceAttribute ( Appears on: AWSCloudMapServiceDiscovery ) AWSCloudMapInstanceAttribute refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_AwsCloudMapInstanceAttribute.html Field Description key string The name of an AWS Cloud Map service instance attribute key. value string The value of an AWS Cloud Map service instance attribute key. AWSCloudMapServiceDiscovery ( Appears on: ServiceDiscovery ) AWSCloudMapServiceDiscovery refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_AwsCloudMapServiceDiscovery.html Field Description namespaceName string The name of the AWS Cloud Map namespace to use. serviceName string The name of the AWS Cloud Map service to use. attributes []AWSCloudMapInstanceAttribute (Optional) A string map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance AccessLog ( Appears on: Logging ) AccessLog refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_AccessLog.html Field Description file FileAccessLog (Optional) The file object to send virtual node access logs to. Backend ( Appears on: VirtualNodeSpec ) Backend refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_Backend.html Field Description virtualService VirtualServiceBackend Specifies a virtual service to use as a backend for a virtual node. BackendDefaults ( Appears on: VirtualNodeSpec ) BackendDefaults refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_BackendDefaults.html Field Description clientPolicy ClientPolicy (Optional) A reference to an object that represents a client policy. ClientPolicy ( Appears on: BackendDefaults , VirtualServiceBackend ) ClientPolicy refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_ClientPolicy.html Field Description tls ClientPolicyTLS (Optional) A reference to an object that represents a Transport Layer Security (TLS) client policy. ClientPolicyTLS ( Appears on: ClientPolicy ) ClientPolicyTLS refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_ClientPolicyTls.html Field Description enforce bool (Optional) Whether the policy is enforced. If unspecified, default settings from AWS API will be applied. Refer to AWS Docs for default settings. ports []PortNumber (Optional) The range of ports that the policy is enforced for. validation TLSValidationContext A reference to an object that represents a TLS validation context. certificate ClientTLSCertificate (Optional) A reference to an object that represents TLS certificate. ClientTLSCertificate ( Appears on: ClientPolicyTLS ) Field Description file ListenerTLSFileCertificate (Optional) An object that represents a TLS cert via a local file sds ListenerTLSSDSCertificate (Optional) An object that represents a TLS cert via SDS entry DNSServiceDiscovery ( Appears on: ServiceDiscovery ) DNSServiceDiscovery refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_DnsServiceDiscovery.html Field Description hostname string Specifies the DNS service discovery hostname for the virtual node. responseType string (Optional) Choose between ENDPOINTS (strict DNS) and LOADBALANCER (logical DNS) mode in Envoy sidecar Duration ( Appears on: GRPCRetryPolicy , GRPCTimeout , HTTPRetryPolicy , HTTPTimeout , OutlierDetection , TCPTimeout ) Field Description unit DurationUnit A unit of time. value int64 A number of time units. DurationUnit ( string alias) ( Appears on: Duration ) EgressFilter ( Appears on: MeshSpec ) EgressFilter refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_EgressFilter.html Field Description type EgressFilterType The egress filter type. EgressFilterType ( string alias) ( Appears on: EgressFilter ) FileAccessLog ( Appears on: AccessLog ) FileAccessLog refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_FileAccessLog.html Field Description path string The file path to write access logs to. GRPCConnectionPool ( Appears on: VirtualGatewayConnectionPool , VirtualNodeConnectionPool ) Field Description maxRequests int64 Represents the maximum number of inflight requests that an envoy can concurrently support across all the hosts in the upstream cluster GRPCGatewayRoute ( Appears on: GatewayRouteSpec ) GRPCGatewayRoute refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/gateway-routes.html Field Description match GRPCGatewayRouteMatch An object that represents the criteria for determining a request match. action GRPCGatewayRouteAction An object that represents the action to take if a match is determined. GRPCGatewayRouteAction ( Appears on: GRPCGatewayRoute ) GRPCGatewayRouteAction refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_GrpcGatewayRouteAction.html Field Description target GatewayRouteTarget An object that represents the target that traffic is routed to when a request matches the route. rewrite GrpcGatewayRouteRewrite (Optional) GRPCGatewayRouteMatch ( Appears on: GRPCGatewayRoute ) GRPCGatewayRouteMatch refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_GrpcGatewayRouteMatch.html Field Description serviceName string (Optional) Either ServiceName or Hostname must be specified. Both are allowed as well The fully qualified domain name for the service to match from the request. hostname GatewayRouteHostnameMatch (Optional) The client specified Hostname to match on. metadata []GRPCGatewayRouteMetadata (Optional) An object that represents the data to match from the request. GRPCGatewayRouteMetadata ( Appears on: GRPCGatewayRouteMatch ) GRPCGatewayRouteMetadata refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_GrpcGatewayRouteMetadata.html Field Description name string The name of the route. match GRPCRouteMetadataMatchMethod (Optional) An object that represents the data to match from the request. invert bool (Optional) Specify True to match anything except the match criteria. The default value is False. GRPCRetryPolicy ( Appears on: GRPCRoute ) GRPCRetryPolicy refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_GrpcRetryPolicy.html Field Description grpcRetryEvents []GRPCRetryPolicyEvent (Optional) httpRetryEvents []HTTPRetryPolicyEvent (Optional) tcpRetryEvents []TCPRetryPolicyEvent (Optional) maxRetries int64 The maximum number of retry attempts. perRetryTimeout Duration An object that represents a duration of time. GRPCRetryPolicyEvent ( string alias) ( Appears on: GRPCRetryPolicy ) GRPCRoute ( Appears on: Route ) GRPCRoute refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_GrpcRoute.html Field Description match GRPCRouteMatch An object that represents the criteria for determining a request match. action GRPCRouteAction An object that represents the action to take if a match is determined. retryPolicy GRPCRetryPolicy (Optional) An object that represents a retry policy. timeout GRPCTimeout (Optional) An object that represents a grpc timeout. GRPCRouteAction ( Appears on: GRPCRoute ) GRPCRouteAction refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_GrpcRouteAction.html Field Description weightedTargets []WeightedTarget An object that represents the targets that traffic is routed to when a request matches the route. GRPCRouteMatch ( Appears on: GRPCRoute ) GRPCRouteMatch refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_GrpcRouteMatch.html Field Description methodName string (Optional) The method name to match from the request. If you specify a name, you must also specify a serviceName. serviceName string (Optional) The fully qualified domain name for the service to match from the request. metadata []GRPCRouteMetadata (Optional) An object that represents the data to match from the request. GRPCRouteMetadata ( Appears on: GRPCRouteMatch ) GRPCRouteMetadata refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_GrpcRouteMetadata.html Field Description name string The name of the route. match GRPCRouteMetadataMatchMethod (Optional) An object that represents the data to match from the request. invert bool (Optional) Specify True to match anything except the match criteria. The default value is False. GRPCRouteMetadataMatchMethod ( Appears on: GRPCGatewayRouteMetadata , GRPCRouteMetadata ) GRPCRouteMetadataMatchMethod refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_GrpcRouteMetadataMatchMethod.html Field Description exact string (Optional) The value sent by the client must match the specified value exactly. prefix string (Optional) The value sent by the client must begin with the specified characters. range MatchRange (Optional) An object that represents the range of values to match on regex string (Optional) The value sent by the client must include the specified characters. suffix string (Optional) The value sent by the client must end with the specified characters. GRPCTimeout ( Appears on: GRPCRoute , ListenerTimeout ) Field Description perRequest Duration (Optional) An object that represents per request timeout duration. idle Duration (Optional) An object that represents idle timeout duration. GatewayRoute GatewayRoute is the Schema for the gatewayroutes API Field Description metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec GatewayRouteSpec awsName string (Optional) AWSName is the AppMesh GatewayRoute object\u2019s name. If unspecified or empty, it defaults to be \u201c${name}_${namespace}\u201d of k8s GatewayRoute priority int64 (Optional) Priority for the gatewayroute. Default Priority is 1000 which is lowest priority grpcRoute GRPCGatewayRoute (Optional) An object that represents the specification of a gRPC gatewayRoute. httpRoute HTTPGatewayRoute (Optional) An object that represents the specification of an HTTP gatewayRoute. http2Route HTTPGatewayRoute (Optional) An object that represents the specification of an HTTP/2 gatewayRoute. virtualGatewayRef VirtualGatewayReference (Optional) A reference to k8s VirtualGateway CR that this GatewayRoute belongs to. The admission controller populates it using VirtualGateway\u2019s selector, and prevents users from setting this field. Populated by the system. Read-only. meshRef MeshReference (Optional) A reference to k8s Mesh CR that this GatewayRoute belongs to. The admission controller populates it using Meshes\u2019s selector, and prevents users from setting this field. Populated by the system. Read-only. status GatewayRouteStatus GatewayRouteCondition ( Appears on: GatewayRouteStatus ) Field Description type GatewayRouteConditionType Type of GatewayRoute condition. status Kubernetes core/v1.ConditionStatus Status of the condition, one of True, False, Unknown. lastTransitionTime Kubernetes meta/v1.Time (Optional) Last time the condition transitioned from one status to another. reason string (Optional) The reason for the condition\u2019s last transition. message string (Optional) A human readable message indicating details about the transition. GatewayRouteConditionType ( string alias) ( Appears on: GatewayRouteCondition ) GatewayRouteHostnameMatch ( Appears on: GRPCGatewayRouteMatch , HTTPGatewayRouteMatch ) Hostname based match, either Exact or Suffix must be specified. Both are not allowed GatewayRouteHostnameMatch refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_GatewayRouteHostnameMatch.html Field Description exact string (Optional) The value sent by the client must match the specified value exactly. suffix string (Optional) The value sent by the client must end with the specified characters. GatewayRouteHostnameRewrite ( Appears on: GrpcGatewayRouteRewrite , HTTPGatewayRouteRewrite ) GatewayRouteHostnameRewrite refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_GatewayRouteHostnameRewrite.html ENABLE or DISABLE default behavior for Hostname rewrite Field Description defaultTargetHostname string (Optional) GatewayRoutePathRewrite ( Appears on: HTTPGatewayRouteRewrite ) GatewayRoutePathRewrite refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_HttpGatewayRoutePathRewrite.html Field Description exact string (Optional) GatewayRoutePrefixRewrite ( Appears on: HTTPGatewayRouteRewrite ) GatewayRoutePrefixRewrite refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_HttpGatewayRoutePrefixRewrite.html Field Description defaultPrefix string (Optional) value string (Optional) When DefaultPrefix is specified, Value cannot be set GatewayRouteSpec ( Appears on: GatewayRoute ) GatewayRouteSpec defines the desired state of GatewayRoute refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_GatewayRouteSpec.html Field Description awsName string (Optional) AWSName is the AppMesh GatewayRoute object\u2019s name. If unspecified or empty, it defaults to be \u201c${name}_${namespace}\u201d of k8s GatewayRoute priority int64 (Optional) Priority for the gatewayroute. Default Priority is 1000 which is lowest priority grpcRoute GRPCGatewayRoute (Optional) An object that represents the specification of a gRPC gatewayRoute. httpRoute HTTPGatewayRoute (Optional) An object that represents the specification of an HTTP gatewayRoute. http2Route HTTPGatewayRoute (Optional) An object that represents the specification of an HTTP/2 gatewayRoute. virtualGatewayRef VirtualGatewayReference (Optional) A reference to k8s VirtualGateway CR that this GatewayRoute belongs to. The admission controller populates it using VirtualGateway\u2019s selector, and prevents users from setting this field. Populated by the system. Read-only. meshRef MeshReference (Optional) A reference to k8s Mesh CR that this GatewayRoute belongs to. The admission controller populates it using Meshes\u2019s selector, and prevents users from setting this field. Populated by the system. Read-only. GatewayRouteStatus ( Appears on: GatewayRoute ) GatewayRouteStatus defines the observed state of GatewayRoute Field Description gatewayRouteARN string (Optional) GatewayRouteARN is the AppMesh GatewayRoute object\u2019s Amazon Resource Name conditions []GatewayRouteCondition (Optional) The current GatewayRoute status. observedGeneration int64 (Optional) The generation observed by the GatewayRoute controller. GatewayRouteTarget ( Appears on: GRPCGatewayRouteAction , HTTPGatewayRouteAction ) GatewayRouteTarget refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_GatewayRouteTarget.html Field Description virtualService GatewayRouteVirtualService The virtual service to associate with the gateway route target. GatewayRouteVirtualService ( Appears on: GatewayRouteTarget ) GatewayRouteVirtualService refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_GatewayRouteVirtualService.html Field Description virtualServiceRef VirtualServiceReference (Optional) Reference to Kubernetes VirtualService CR in cluster to associate with the gateway route virtual service target. Exactly one of \u2018virtualServiceRef\u2019 or \u2018virtualServiceARN\u2019 must be specified. virtualServiceARN string (Optional) Amazon Resource Name to AppMesh VirtualService object to associate with the gateway route virtual service target. Exactly one of \u2018virtualServiceRef\u2019 or \u2018virtualServiceARN\u2019 must be specified. GrpcGatewayRouteRewrite ( Appears on: GRPCGatewayRouteAction ) GrpcGatewayRouteRewrite refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_GrpcGatewayRouteRewrite.html Field Description hostname GatewayRouteHostnameRewrite HTTP2ConnectionPool ( Appears on: VirtualGatewayConnectionPool , VirtualNodeConnectionPool ) Field Description maxRequests int64 Represents the maximum number of inflight requests that an envoy can concurrently support across all the hosts in the upstream cluster HTTPConnectionPool ( Appears on: VirtualGatewayConnectionPool , VirtualNodeConnectionPool ) Field Description maxConnections int64 Represents the maximum number of outbound TCP connections the envoy can establish concurrently with all the hosts in the upstream cluster. maxPendingRequests int64 (Optional) Represents the number of overflowing requests after max_connections that an envoy will queue to an upstream cluster. HTTPGatewayRoute ( Appears on: GatewayRouteSpec ) HTTPGatewayRoute refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/gateway-routes.html Field Description match HTTPGatewayRouteMatch An object that represents the criteria for determining a request match. action HTTPGatewayRouteAction An object that represents the action to take if a match is determined. HTTPGatewayRouteAction ( Appears on: HTTPGatewayRoute ) HTTPGatewayRouteAction refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_HttpGatewayRouteAction.html Field Description target GatewayRouteTarget An object that represents the target that traffic is routed to when a request matches the route. rewrite HTTPGatewayRouteRewrite (Optional) HTTPGatewayRouteHeader ( Appears on: HTTPGatewayRouteMatch ) HTTPGatewayRouteHeader refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_HttpGatewayRouteHeader.html Field Description name string A name for the HTTP header in the client request that will be matched on. match HeaderMatchMethod (Optional) The HeaderMatchMethod object. invert bool (Optional) Specify True to match anything except the match criteria. The default value is False. HTTPGatewayRouteMatch ( Appears on: HTTPGatewayRoute ) HTTPGatewayRouteMatch refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_HttpGatewayRouteMatch.html Field Description prefix string (Optional) Either Prefix or Hostname must be specified. Both are allowed as well. Specifies the prefix to match requests with path HTTPPathMatch (Optional) Specified path of the request to be matched on queryParameters []HTTPQueryParameters (Optional) Client specified query parameters to match on method string (Optional) The client request method to match on. hostname GatewayRouteHostnameMatch (Optional) The client specified Hostname to match on. headers []HTTPGatewayRouteHeader (Optional) An object that represents the client request headers to match on. HTTPGatewayRouteRewrite ( Appears on: HTTPGatewayRouteAction ) HTTPGatewayRouteRewrite refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_HttpGatewayRouteRewrite.html Field Description prefix GatewayRoutePrefixRewrite (Optional) path GatewayRoutePathRewrite (Optional) hostname GatewayRouteHostnameRewrite (Optional) HTTPPathMatch ( Appears on: HTTPGatewayRouteMatch , HTTPRouteMatch ) HTTPPathMatch refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_HttpPathMatch.html Field Description exact string (Optional) The value sent by the client must match the specified value exactly. regex string (Optional) The value sent by the client must end with the specified characters. HTTPQueryParameters ( Appears on: HTTPGatewayRouteMatch , HTTPRouteMatch ) HTTPQueryParameters refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_HttpQueryParameter.html Field Description name string match QueryMatchMethod (Optional) The QueryMatchMethod object. HTTPRetryPolicy ( Appears on: HTTPRoute ) HTTPRetryPolicy refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_HttpRetryPolicy.html Field Description httpRetryEvents []HTTPRetryPolicyEvent (Optional) tcpRetryEvents []TCPRetryPolicyEvent (Optional) maxRetries int64 The maximum number of retry attempts. perRetryTimeout Duration An object that represents a duration of time HTTPRetryPolicyEvent ( string alias) ( Appears on: GRPCRetryPolicy , HTTPRetryPolicy ) HTTPRoute ( Appears on: Route ) HTTPRoute refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_HttpRoute.html Field Description match HTTPRouteMatch An object that represents the criteria for determining a request match. action HTTPRouteAction An object that represents the action to take if a match is determined. retryPolicy HTTPRetryPolicy (Optional) An object that represents a retry policy. timeout HTTPTimeout (Optional) An object that represents a http timeout. HTTPRouteAction ( Appears on: HTTPRoute ) HTTPRouteAction refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_HttpRouteAction.html Field Description weightedTargets []WeightedTarget An object that represents the targets that traffic is routed to when a request matches the route. HTTPRouteHeader ( Appears on: HTTPRouteMatch ) HTTPRouteHeader refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_HttpRouteHeader.html Field Description name string A name for the HTTP header in the client request that will be matched on. match HeaderMatchMethod (Optional) The HeaderMatchMethod object. invert bool (Optional) Specify True to match anything except the match criteria. The default value is False. HTTPRouteMatch ( Appears on: HTTPRoute ) HTTPRouteMatch refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_HttpRouteMatch.html Field Description headers []HTTPRouteHeader (Optional) An object that represents the client request headers to match on. method string (Optional) The client request method to match on. prefix string (Optional) Specifies the prefix to match requests with scheme string (Optional) The client request scheme to match on path HTTPPathMatch (Optional) The client specified Path to match on. queryParameters []HTTPQueryParameters (Optional) The client specified queryParameters to match on HTTPTimeout ( Appears on: HTTPRoute , ListenerTimeout ) Field Description perRequest Duration (Optional) An object that represents per request timeout duration. idle Duration (Optional) An object that represents idle timeout duration. HeaderMatchMethod ( Appears on: HTTPGatewayRouteHeader , HTTPRouteHeader ) HeaderMatchMethod refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_HeaderMatchMethod.html Field Description exact string (Optional) The value sent by the client must match the specified value exactly. prefix string (Optional) The value sent by the client must begin with the specified characters. range MatchRange (Optional) An object that represents the range of values to match on. regex string (Optional) The value sent by the client must include the specified characters. suffix string (Optional) The value sent by the client must end with the specified characters. HealthCheckPolicy ( Appears on: Listener ) HealthCheckPolicy refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_HealthCheckPolicy.html Field Description healthyThreshold int64 The number of consecutive successful health checks that must occur before declaring listener healthy. intervalMillis int64 The time period in milliseconds between each health check execution. path string (Optional) The destination path for the health check request. This value is only used if the specified protocol is http or http2. For any other protocol, this value is ignored. port PortNumber (Optional) The destination port for the health check request. protocol PortProtocol The protocol for the health check request timeoutMillis int64 The amount of time to wait when receiving a response from the health check, in milliseconds. unhealthyThreshold int64 The number of consecutive failed health checks that must occur before declaring a virtual node unhealthy. Listener ( Appears on: VirtualNodeSpec ) Listener refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_Listener.html Field Description portMapping PortMapping The port mapping information for the listener. healthCheck HealthCheckPolicy (Optional) The health check information for the listener. outlierDetection OutlierDetection (Optional) The outlier detection for the listener connectionPool VirtualNodeConnectionPool (Optional) The connection pool settings for the listener tls ListenerTLS (Optional) A reference to an object that represents the Transport Layer Security (TLS) properties for a listener. timeout ListenerTimeout (Optional) A reference to an object that represents ListenerTLS ( Appears on: Listener ) ListenerTLS refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_ListenerTls.html Field Description certificate ListenerTLSCertificate A reference to an object that represents a listener\u2019s TLS certificate. mode ListenerTLSMode ListenerTLS mode validation ListenerTLSValidationContext (Optional) A reference to an object that represents an SDS Trust Domain ListenerTLSACMCertificate ( Appears on: ListenerTLSCertificate ) ListenerTLSACMCertificate refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_ListenerTlsAcmCertificate.html Field Description certificateARN string The Amazon Resource Name (ARN) for the certificate. ListenerTLSCertificate ( Appears on: ListenerTLS ) ListenerTLSCertificate refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_ListenerTlsCertificate.html Field Description acm ListenerTLSACMCertificate (Optional) A reference to an object that represents an AWS Certificate Manager (ACM) certificate. file ListenerTLSFileCertificate (Optional) A reference to an object that represents a local file certificate. sds ListenerTLSSDSCertificate (Optional) A reference to an object that represents an SDS certificate. ListenerTLSFileCertificate ( Appears on: ClientTLSCertificate , ListenerTLSCertificate ) ListenerTLSFileCertificate refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_ListenerTlsFileCertificate.html Field Description certificateChain string The certificate chain for the certificate. privateKey string The private key for a certificate stored on the file system of the virtual node that the proxy is running on. ListenerTLSMode ( string alias) ( Appears on: ListenerTLS ) ListenerTLSSDSCertificate ( Appears on: ClientTLSCertificate , ListenerTLSCertificate ) ListenerTLSSDSCertificate refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_ListenerTlsFileCertificate.html Field Description secretName string The certificate trust chain for a certificate issued via SDS cluster ListenerTLSValidationContext ( Appears on: ListenerTLS ) Field Description trust ListenerTLSValidationContextTrust subjectAlternativeNames SubjectAlternativeNames (Optional) Possible alternative names to consider ListenerTLSValidationContextTrust ( Appears on: ListenerTLSValidationContext ) Field Description file TLSValidationContextFileTrust (Optional) An object that represents a TLS validation context trust for a local file. sds TLSValidationContextSDSTrust (Optional) An object that represents a TLS validation context trust for an SDS server ListenerTimeout ( Appears on: Listener ) ListenerTimeout refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_ListenerTimeout.html Field Description tcp TCPTimeout (Optional) Specifies tcp timeout information for the virtual node. http HTTPTimeout (Optional) Specifies http timeout information for the virtual node. http2 HTTPTimeout (Optional) Specifies http2 information for the virtual node. grpc GRPCTimeout (Optional) Specifies grpc timeout information for the virtual node. Logging ( Appears on: VirtualNodeSpec ) Logging refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_Logging.html Field Description accessLog AccessLog (Optional) The access log configuration for a virtual node. MatchRange ( Appears on: GRPCRouteMetadataMatchMethod , HeaderMatchMethod ) Field Description start int64 The start of the range. end int64 The end of the range. Mesh Mesh is the Schema for the meshes API Field Description metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec MeshSpec awsName string (Optional) AWSName is the AppMesh Mesh object\u2019s name. If unspecified or empty, it defaults to be \u201c${name}\u201d of k8s Mesh namespaceSelector Kubernetes meta/v1.LabelSelector (Optional) NamespaceSelector selects Namespaces using labels to designate mesh membership. This field follows standard label selector semantics: if present but empty, it selects all namespaces. if absent, it selects no namespace. egressFilter EgressFilter (Optional) The egress filter rules for the service mesh. If unspecified, default settings from AWS API will be applied. Refer to AWS Docs for default settings. meshOwner string (Optional) The AWS IAM account ID of the service mesh owner. Required if the account ID is not your own. status MeshStatus MeshCondition ( Appears on: MeshStatus ) Field Description type MeshConditionType Type of mesh condition. status Kubernetes core/v1.ConditionStatus Status of the condition, one of True, False, Unknown. lastTransitionTime Kubernetes meta/v1.Time (Optional) Last time the condition transitioned from one status to another. reason string (Optional) The reason for the condition\u2019s last transition. message string (Optional) A human readable message indicating details about the transition. MeshConditionType ( string alias) ( Appears on: MeshCondition ) MeshReference ( Appears on: GatewayRouteSpec , VirtualGatewaySpec , VirtualNodeSpec , VirtualRouterSpec , VirtualServiceSpec ) MeshReference holds a reference to Mesh.appmesh.k8s.aws Field Description name string Name is the name of Mesh CR uid k8s.io/apimachinery/pkg/types.UID UID is the UID of Mesh CR MeshSpec ( Appears on: Mesh ) MeshSpec defines the desired state of Mesh refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_MeshSpec.html Field Description awsName string (Optional) AWSName is the AppMesh Mesh object\u2019s name. If unspecified or empty, it defaults to be \u201c${name}\u201d of k8s Mesh namespaceSelector Kubernetes meta/v1.LabelSelector (Optional) NamespaceSelector selects Namespaces using labels to designate mesh membership. This field follows standard label selector semantics: if present but empty, it selects all namespaces. if absent, it selects no namespace. egressFilter EgressFilter (Optional) The egress filter rules for the service mesh. If unspecified, default settings from AWS API will be applied. Refer to AWS Docs for default settings. meshOwner string (Optional) The AWS IAM account ID of the service mesh owner. Required if the account ID is not your own. MeshStatus ( Appears on: Mesh ) MeshStatus defines the observed state of Mesh Field Description meshARN string (Optional) MeshARN is the AppMesh Mesh object\u2019s Amazon Resource Name conditions []MeshCondition (Optional) The current Mesh status. observedGeneration int64 (Optional) The generation observed by the Mesh controller. OutlierDetection ( Appears on: Listener ) OutlierDetection defines the health check policy that temporarily ejects an endpoint/host of a VirtualNode from the load balancing set when it meets failure threshold Field Description maxServerErrors int64 The threshold for the number of server errors returned by a given host during an outlier detection interval. If the server error count meets/exceeds this threshold the host is ejected. A server error is defined as any HTTP 5xx response (or the equivalent for gRPC and TCP connections) interval Duration The time interval between ejection analysis sweeps. This can result in both new ejections as well as hosts being returned to service baseEjectionDuration Duration The base time that a host is ejected for. The real time is equal to the base time multiplied by the number of times the host has been ejected maxEjectionPercent int64 The threshold for the max percentage of outlier hosts that can be ejected from the load balancing set. maxEjectionPercent=100 means outlier detection can potentially eject all of the hosts from the upstream service if they are all considered outliers, leaving the load balancing set with zero hosts PortMapping ( Appears on: Listener , VirtualRouterListener ) PortMapping refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_PortMapping.html Field Description port PortNumber The port used for the port mapping. protocol PortProtocol The protocol used for the port mapping. PortNumber ( int64 alias) ( Appears on: ClientPolicyTLS , HealthCheckPolicy , PortMapping , VirtualGatewayClientPolicyTLS , VirtualGatewayHealthCheckPolicy , VirtualGatewayPortMapping ) PortProtocol ( string alias) ( Appears on: HealthCheckPolicy , PortMapping ) QueryMatchMethod ( Appears on: HTTPQueryParameters ) Field Description exact string (Optional) Route ( Appears on: VirtualRouterSpec ) Route refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_RouteSpec.html Field Description name string Route\u2019s name grpcRoute GRPCRoute (Optional) An object that represents the specification of a gRPC route. httpRoute HTTPRoute (Optional) An object that represents the specification of an HTTP route. http2Route HTTPRoute (Optional) An object that represents the specification of an HTTP/2 route. tcpRoute TCPRoute (Optional) An object that represents the specification of a TCP route. priority int64 (Optional) The priority for the route. ServiceDiscovery ( Appears on: VirtualNodeSpec ) ServiceDiscovery refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_ServiceDiscovery.html Field Description awsCloudMap AWSCloudMapServiceDiscovery (Optional) Specifies any AWS Cloud Map information for the virtual node. dns DNSServiceDiscovery (Optional) Specifies the DNS information for the virtual node. SubjectAlternativeNameMatchers ( Appears on: SubjectAlternativeNames ) Field Description exact []string Exact is a required field SubjectAlternativeNames ( Appears on: ListenerTLSValidationContext , TLSValidationContext , VirtualGatewayListenerTLSValidationContext , VirtualGatewayTLSValidationContext ) Field Description match SubjectAlternativeNameMatchers Match is a required field TCPConnectionPool ( Appears on: VirtualNodeConnectionPool ) Field Description maxConnections int64 Represents the maximum number of outbound TCP connections the envoy can establish concurrently with all the hosts in the upstream cluster. TCPRetryPolicyEvent ( string alias) ( Appears on: GRPCRetryPolicy , HTTPRetryPolicy ) TCPRoute ( Appears on: Route ) TCPRoute refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_TcpRoute.html Field Description action TCPRouteAction The action to take if a match is determined. timeout TCPTimeout (Optional) An object that represents a tcp timeout. TCPRouteAction ( Appears on: TCPRoute ) TCPRouteAction refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_TcpRouteAction.html Field Description weightedTargets []WeightedTarget An object that represents the targets that traffic is routed to when a request matches the route. TCPTimeout ( Appears on: ListenerTimeout , TCPRoute ) Field Description idle Duration (Optional) An object that represents idle timeout duration. TLSValidationContext ( Appears on: ClientPolicyTLS ) TLSValidationContext refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_TlsValidationContext.html Field Description trust TLSValidationContextTrust A reference to an object that represents a TLS validation context trust subjectAlternativeNames SubjectAlternativeNames (Optional) Possible Alternative names to consider TLSValidationContextACMTrust ( Appears on: TLSValidationContextTrust ) TLSValidationContextACMTrust refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_TlsValidationContextAcmTrust.html Field Description certificateAuthorityARNs []string One or more ACM Amazon Resource Name (ARN)s. TLSValidationContextFileTrust ( Appears on: ListenerTLSValidationContextTrust , TLSValidationContextTrust ) TLSValidationContextFileTrust refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_TlsValidationContextFileTrust.html Field Description certificateChain string The certificate trust chain for a certificate stored on the file system of the virtual node that the proxy is running on. TLSValidationContextSDSTrust ( Appears on: ListenerTLSValidationContextTrust , TLSValidationContextTrust ) TLSValidationContextSDSTrust refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_TlsValidationContextFileTrust.html Field Description secretName string The certificate trust chain for a certificate obtained via SDS TLSValidationContextTrust ( Appears on: TLSValidationContext ) TLSValidationContextTrust refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_TlsValidationContextTrust.html Field Description acm TLSValidationContextACMTrust (Optional) A reference to an object that represents a TLS validation context trust for an AWS Certicate Manager (ACM) certificate. file TLSValidationContextFileTrust (Optional) An object that represents a TLS validation context trust for a local file. sds TLSValidationContextSDSTrust (Optional) An object that represents a TLS validation context trust for a SDS. VirtualGateway VirtualGateway is the Schema for the virtualgateways API Field Description metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec VirtualGatewaySpec awsName string (Optional) AWSName is the AppMesh VirtualGateway object\u2019s name. If unspecified or empty, it defaults to be \u201c${name}_${namespace}\u201d of k8s VirtualGateway namespaceSelector Kubernetes meta/v1.LabelSelector (Optional) NamespaceSelector selects Namespaces using labels to designate GatewayRoute membership. This field follows standard label selector semantics; if present but empty, it selects all namespaces. podSelector Kubernetes meta/v1.LabelSelector (Optional) PodSelector selects Pods using labels to designate VirtualGateway membership. This field follows standard label selector semantics: if present but empty, it selects all pods within namespace. if absent, it selects no pod. gatewayRouteSelector Kubernetes meta/v1.LabelSelector (Optional) GatewayRouteSelector selects GatewayRoutes using labels to designate GatewayRoute membership. If not specified it selects all GatewayRoutes in that namespace. listeners []VirtualGatewayListener The listener that the virtual gateway is expected to receive inbound traffic from logging VirtualGatewayLogging (Optional) The inbound and outbound access logging information for the virtual gateway. backendDefaults VirtualGatewayBackendDefaults (Optional) A reference to an object that represents the defaults for backend GatewayRoutes. meshRef MeshReference (Optional) A reference to k8s Mesh CR that this VirtualGateway belongs to. The admission controller populates it using Meshes\u2019s selector, and prevents users from setting this field. Populated by the system. Read-only. status VirtualGatewayStatus VirtualGatewayAccessLog ( Appears on: VirtualGatewayLogging ) VirtualGatewayAccessLog refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description file VirtualGatewayFileAccessLog (Optional) The file object to send virtual gateway access logs to. VirtualGatewayBackendDefaults ( Appears on: VirtualGatewaySpec ) VirtualGatewayBackendDefaults refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description clientPolicy VirtualGatewayClientPolicy (Optional) A reference to an object that represents a client policy. VirtualGatewayClientPolicy ( Appears on: VirtualGatewayBackendDefaults ) VirtualGatewayClientPolicy refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description tls VirtualGatewayClientPolicyTLS (Optional) A reference to an object that represents a Transport Layer Security (TLS) client policy. VirtualGatewayClientPolicyTLS ( Appears on: VirtualGatewayClientPolicy ) VirtualGatewayClientPolicyTLS refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description enforce bool (Optional) Whether the policy is enforced. If unspecified, default settings from AWS API will be applied. Refer to AWS Docs for default settings. ports []PortNumber (Optional) The range of ports that the policy is enforced for. certificate VirtualGatewayClientTLSCertificate (Optional) A reference to an object that represents TLS certificate. validation VirtualGatewayTLSValidationContext A reference to an object that represents a TLS validation context. VirtualGatewayClientTLSCertificate ( Appears on: VirtualGatewayClientPolicyTLS ) VirtualGatewayTLSValidationContext refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description file VirtualGatewayListenerTLSFileCertificate (Optional) An object that represents a TLS cert via a local file sds VirtualGatewayListenerTLSSDSCertificate (Optional) An object that represents a TLS cert via SDS entry VirtualGatewayCondition ( Appears on: VirtualGatewayStatus ) Field Description type VirtualGatewayConditionType Type of VirtualGateway condition. status Kubernetes core/v1.ConditionStatus Status of the condition, one of True, False, Unknown. lastTransitionTime Kubernetes meta/v1.Time (Optional) Last time the condition transitioned from one status to another. reason string (Optional) The reason for the condition\u2019s last transition. message string (Optional) A human readable message indicating details about the transition. VirtualGatewayConditionType ( string alias) ( Appears on: VirtualGatewayCondition ) VirtualGatewayConnectionPool ( Appears on: VirtualGatewayListener ) VirtualGatewayConnectionPool refers to the connection pools settings for Virtual Gateway. Connection pool limits the number of connections that an Envoy can concurrently establish with all the hosts in the upstream cluster. Currently connection pool is supported only at the listener level and it is intended protect your local application from being overwhelmed with connections. Field Description http HTTPConnectionPool (Optional) Specifies http connection pool settings for the virtual gateway listener http2 HTTP2ConnectionPool (Optional) Specifies http2 connection pool settings for the virtual gateway listener grpc GRPCConnectionPool (Optional) Specifies grpc connection pool settings for the virtual gateway listener VirtualGatewayFileAccessLog ( Appears on: VirtualGatewayAccessLog ) VirtualGatewayFileAccessLog refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description path string The file path to write access logs to. VirtualGatewayHealthCheckPolicy ( Appears on: VirtualGatewayListener ) VirtualGatewayHealthCheckPolicy refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description healthyThreshold int64 (Optional) The number of consecutive successful health checks that must occur before declaring listener healthy. intervalMillis int64 The time period in milliseconds between each health check execution. path string (Optional) The destination path for the health check request. This value is only used if the specified protocol is http or http2. For any other protocol, this value is ignored. port PortNumber (Optional) The destination port for the health check request. protocol VirtualGatewayPortProtocol The protocol for the health check request timeoutMillis int64 The amount of time to wait when receiving a response from the health check, in milliseconds. unhealthyThreshold int64 The number of consecutive failed health checks that must occur before declaring a virtual Gateway unhealthy. VirtualGatewayListener ( Appears on: VirtualGatewaySpec ) VirtualGatewayListener refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description portMapping VirtualGatewayPortMapping The port mapping information for the listener. healthCheck VirtualGatewayHealthCheckPolicy (Optional) The health check information for the listener. connectionPool VirtualGatewayConnectionPool (Optional) The connection pool settings for the listener tls VirtualGatewayListenerTLS (Optional) A reference to an object that represents the Transport Layer Security (TLS) properties for a listener. VirtualGatewayListenerTLS ( Appears on: VirtualGatewayListener ) VirtualGatewayListenerTLS refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description certificate VirtualGatewayListenerTLSCertificate A reference to an object that represents a listener\u2019s TLS certificate. validation VirtualGatewayListenerTLSValidationContext (Optional) A reference to an object that represents Validation context mode VirtualGatewayListenerTLSMode ListenerTLS mode VirtualGatewayListenerTLSACMCertificate ( Appears on: VirtualGatewayListenerTLSCertificate ) VirtualGatewayListenerTLSACMCertificate refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description certificateARN string The Amazon Resource Name (ARN) for the certificate. VirtualGatewayListenerTLSCertificate ( Appears on: VirtualGatewayListenerTLS ) VirtualGatewayListenerTLSCertificate refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description acm VirtualGatewayListenerTLSACMCertificate (Optional) A reference to an object that represents an AWS Certificate Manager (ACM) certificate. file VirtualGatewayListenerTLSFileCertificate (Optional) A reference to an object that represents a local file certificate. sds VirtualGatewayListenerTLSSDSCertificate (Optional) A reference to an object that represents an SDS issued certificate VirtualGatewayListenerTLSFileCertificate ( Appears on: VirtualGatewayClientTLSCertificate , VirtualGatewayListenerTLSCertificate ) VirtualGatewayListenerTLSFileCertificate refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description certificateChain string The certificate chain for the certificate. privateKey string The private key for a certificate stored on the file system of the virtual Gateway. VirtualGatewayListenerTLSMode ( string alias) ( Appears on: VirtualGatewayListenerTLS ) VirtualGatewayListenerTLSSDSCertificate ( Appears on: VirtualGatewayClientTLSCertificate , VirtualGatewayListenerTLSCertificate ) Field Description secretName string The certificate trust chain for a certificate issued via SDS cluster VirtualGatewayListenerTLSValidationContext ( Appears on: VirtualGatewayListenerTLS ) VirtualGatewayListenerTLSCertificate refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description trust VirtualGatewayListenerTLSValidationContextTrust subjectAlternativeNames SubjectAlternativeNames (Optional) Possible alternate names to consider VirtualGatewayListenerTLSValidationContextTrust ( Appears on: VirtualGatewayListenerTLSValidationContext ) Field Description acm VirtualGatewayTLSValidationContextACMTrust (Optional) A reference to an object that represents a TLS validation context trust for an AWS Certicate Manager (ACM) certificate. file VirtualGatewayTLSValidationContextFileTrust (Optional) An object that represents a TLS validation context trust for a local file. sds VirtualGatewayTLSValidationContextSDSTrust (Optional) An object that represents a TLS validation context trust for an SDS system VirtualGatewayLogging ( Appears on: VirtualGatewaySpec ) VirtualGatewayLogging refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description accessLog VirtualGatewayAccessLog (Optional) The access log configuration for a virtual Gateway. VirtualGatewayPortMapping ( Appears on: VirtualGatewayListener ) VirtualGatewayPortMapping refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description port PortNumber The port used for the port mapping. protocol VirtualGatewayPortProtocol The protocol used for the port mapping. VirtualGatewayPortProtocol ( string alias) ( Appears on: VirtualGatewayHealthCheckPolicy , VirtualGatewayPortMapping ) VirtualGatewayReference ( Appears on: GatewayRouteSpec ) VirtualGatewayReference holds a reference to VirtualGateway.appmesh.k8s.aws Field Description namespace string (Optional) Namespace is the namespace of VirtualGateway CR. If unspecified, defaults to the referencing object\u2019s namespace name string Name is the name of VirtualGateway CR uid k8s.io/apimachinery/pkg/types.UID UID is the UID of VirtualGateway CR VirtualGatewaySpec ( Appears on: VirtualGateway ) VirtualGatewaySpec defines the desired state of VirtualGateway refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description awsName string (Optional) AWSName is the AppMesh VirtualGateway object\u2019s name. If unspecified or empty, it defaults to be \u201c${name}_${namespace}\u201d of k8s VirtualGateway namespaceSelector Kubernetes meta/v1.LabelSelector (Optional) NamespaceSelector selects Namespaces using labels to designate GatewayRoute membership. This field follows standard label selector semantics; if present but empty, it selects all namespaces. podSelector Kubernetes meta/v1.LabelSelector (Optional) PodSelector selects Pods using labels to designate VirtualGateway membership. This field follows standard label selector semantics: if present but empty, it selects all pods within namespace. if absent, it selects no pod. gatewayRouteSelector Kubernetes meta/v1.LabelSelector (Optional) GatewayRouteSelector selects GatewayRoutes using labels to designate GatewayRoute membership. If not specified it selects all GatewayRoutes in that namespace. listeners []VirtualGatewayListener The listener that the virtual gateway is expected to receive inbound traffic from logging VirtualGatewayLogging (Optional) The inbound and outbound access logging information for the virtual gateway. backendDefaults VirtualGatewayBackendDefaults (Optional) A reference to an object that represents the defaults for backend GatewayRoutes. meshRef MeshReference (Optional) A reference to k8s Mesh CR that this VirtualGateway belongs to. The admission controller populates it using Meshes\u2019s selector, and prevents users from setting this field. Populated by the system. Read-only. VirtualGatewayStatus ( Appears on: VirtualGateway ) VirtualGatewayStatus defines the observed state of VirtualGateway Field Description virtualGatewayARN string (Optional) VirtualGatewayARN is the AppMesh VirtualGateway object\u2019s Amazon Resource Name conditions []VirtualGatewayCondition (Optional) The current VirtualGateway status. observedGeneration int64 (Optional) The generation observed by the VirtualGateway controller. VirtualGatewayTLSValidationContext ( Appears on: VirtualGatewayClientPolicyTLS ) VirtualGatewayTLSValidationContext refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description trust VirtualGatewayTLSValidationContextTrust A reference to an object that represents a TLS validation context trust subjectAlternativeNames SubjectAlternativeNames (Optional) Possible alternative names to consider VirtualGatewayTLSValidationContextACMTrust ( Appears on: VirtualGatewayListenerTLSValidationContextTrust , VirtualGatewayTLSValidationContextTrust ) VirtualGatewayTLSValidationContextACMTrust refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description certificateAuthorityARNs []string One or more ACM Amazon Resource Name (ARN)s. VirtualGatewayTLSValidationContextFileTrust ( Appears on: VirtualGatewayListenerTLSValidationContextTrust , VirtualGatewayTLSValidationContextTrust ) VirtualGatewayTLSValidationContextFileTrust refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description certificateChain string The certificate trust chain for a certificate stored on the file system of the virtual Gateway. VirtualGatewayTLSValidationContextSDSTrust ( Appears on: VirtualGatewayListenerTLSValidationContextTrust , VirtualGatewayTLSValidationContextTrust ) VirtualGatewayTLSValidationContextSDSTrust refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description secretName string The certificate trust chain for a certificate issued via SDS. VirtualGatewayTLSValidationContextTrust ( Appears on: VirtualGatewayTLSValidationContext ) VirtualGatewayTLSValidationContextTrust refers to https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html Field Description acm VirtualGatewayTLSValidationContextACMTrust (Optional) A reference to an object that represents a TLS validation context trust for an AWS Certicate Manager (ACM) certificate. file VirtualGatewayTLSValidationContextFileTrust (Optional) An object that represents a TLS validation context trust for a local file. sds VirtualGatewayTLSValidationContextSDSTrust (Optional) An object that represents a TLS validation context trust for a SDS certificate VirtualNode VirtualNode is the Schema for the virtualnodes API Field Description metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec VirtualNodeSpec awsName string (Optional) AWSName is the AppMesh VirtualNode object\u2019s name. If unspecified or empty, it defaults to be \u201c${name}_${namespace}\u201d of k8s VirtualNode podSelector Kubernetes meta/v1.LabelSelector (Optional) PodSelector selects Pods using labels to designate VirtualNode membership. This field follows standard label selector semantics: if present but empty, it selects all pods within namespace. if absent, it selects no pod. listeners []Listener (Optional) The listener that the virtual node is expected to receive inbound traffic from serviceDiscovery ServiceDiscovery (Optional) The service discovery information for the virtual node. Optional if there is no inbound traffic(no listeners). Mandatory if a listener is specified. backends []Backend (Optional) The backends that the virtual node is expected to send outbound traffic to. backendDefaults BackendDefaults (Optional) A reference to an object that represents the defaults for backends. logging Logging (Optional) The inbound and outbound access logging information for the virtual node. meshRef MeshReference (Optional) A reference to k8s Mesh CR that this VirtualNode belongs to. The admission controller populates it using Meshes\u2019s selector, and prevents users from setting this field. Populated by the system. Read-only. status VirtualNodeStatus VirtualNodeCondition ( Appears on: VirtualNodeStatus ) Field Description type VirtualNodeConditionType Type of VirtualNode condition. status Kubernetes core/v1.ConditionStatus Status of the condition, one of True, False, Unknown. lastTransitionTime Kubernetes meta/v1.Time (Optional) Last time the condition transitioned from one status to another. reason string (Optional) The reason for the condition\u2019s last transition. message string (Optional) A human readable message indicating details about the transition. VirtualNodeConditionType ( string alias) ( Appears on: VirtualNodeCondition ) VirtualNodeConnectionPool ( Appears on: Listener ) VirtualNodeConnectionPool refers to the connection pools settings for Virtual Node. Connection pool limits the number of connections that an Envoy can concurrently establish with all the hosts in the upstream cluster. Currently connection pool is supported only at the listener level and it is intended protect your local application from being overwhelmed with connections. Field Description tcp TCPConnectionPool (Optional) Specifies tcp connection pool settings for the virtual node listener http HTTPConnectionPool (Optional) Specifies http connection pool settings for the virtual node listener http2 HTTP2ConnectionPool (Optional) Specifies http2 connection pool settings for the virtual node listener grpc GRPCConnectionPool (Optional) Specifies grpc connection pool settings for the virtual node listener VirtualNodeReference ( Appears on: VirtualNodeServiceProvider , WeightedTarget ) VirtualNodeReference holds a reference to VirtualNode.appmesh.k8s.aws Field Description namespace string (Optional) Namespace is the namespace of VirtualNode CR. If unspecified, defaults to the referencing object\u2019s namespace name string Name is the name of VirtualNode CR VirtualNodeServiceProvider ( Appears on: VirtualServiceProvider ) VirtualNodeServiceProvider refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_VirtualNodeServiceProvider.html Field Description virtualNodeRef VirtualNodeReference (Optional) Reference to Kubernetes VirtualNode CR in cluster that is acting as a service provider. Exactly one of \u2018virtualNodeRef\u2019 or \u2018virtualNodeARN\u2019 must be specified. virtualNodeARN string (Optional) Amazon Resource Name to AppMesh VirtualNode object that is acting as a service provider. Exactly one of \u2018virtualNodeRef\u2019 or \u2018virtualNodeARN\u2019 must be specified. VirtualNodeSpec ( Appears on: VirtualNode ) VirtualNodeSpec defines the desired state of VirtualNode refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_VirtualNodeSpec.html Field Description awsName string (Optional) AWSName is the AppMesh VirtualNode object\u2019s name. If unspecified or empty, it defaults to be \u201c${name}_${namespace}\u201d of k8s VirtualNode podSelector Kubernetes meta/v1.LabelSelector (Optional) PodSelector selects Pods using labels to designate VirtualNode membership. This field follows standard label selector semantics: if present but empty, it selects all pods within namespace. if absent, it selects no pod. listeners []Listener (Optional) The listener that the virtual node is expected to receive inbound traffic from serviceDiscovery ServiceDiscovery (Optional) The service discovery information for the virtual node. Optional if there is no inbound traffic(no listeners). Mandatory if a listener is specified. backends []Backend (Optional) The backends that the virtual node is expected to send outbound traffic to. backendDefaults BackendDefaults (Optional) A reference to an object that represents the defaults for backends. logging Logging (Optional) The inbound and outbound access logging information for the virtual node. meshRef MeshReference (Optional) A reference to k8s Mesh CR that this VirtualNode belongs to. The admission controller populates it using Meshes\u2019s selector, and prevents users from setting this field. Populated by the system. Read-only. VirtualNodeStatus ( Appears on: VirtualNode ) VirtualNodeStatus defines the observed state of VirtualNode Field Description virtualNodeARN string (Optional) VirtualNodeARN is the AppMesh VirtualNode object\u2019s Amazon Resource Name conditions []VirtualNodeCondition (Optional) The current VirtualNode status. observedGeneration int64 (Optional) The generation observed by the VirtualNode controller. VirtualRouter VirtualRouter is the Schema for the virtualrouters API Field Description metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec VirtualRouterSpec awsName string (Optional) AWSName is the AppMesh VirtualRouter object\u2019s name. If unspecified or empty, it defaults to be \u201c${name}_${namespace}\u201d of k8s VirtualRouter listeners []VirtualRouterListener The listeners that the virtual router is expected to receive inbound traffic from routes []Route (Optional) The routes associated with VirtualRouter meshRef MeshReference (Optional) A reference to k8s Mesh CR that this VirtualRouter belongs to. The admission controller populates it using Meshes\u2019s selector, and prevents users from setting this field. Populated by the system. Read-only. status VirtualRouterStatus VirtualRouterCondition ( Appears on: VirtualRouterStatus ) Field Description type VirtualRouterConditionType Type of VirtualRouter condition. status Kubernetes core/v1.ConditionStatus Status of the condition, one of True, False, Unknown. lastTransitionTime Kubernetes meta/v1.Time (Optional) Last time the condition transitioned from one status to another. reason string (Optional) The reason for the condition\u2019s last transition. message string (Optional) A human readable message indicating details about the transition. VirtualRouterConditionType ( string alias) ( Appears on: VirtualRouterCondition ) VirtualRouterListener ( Appears on: VirtualRouterSpec ) VirtualRouterListener refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_VirtualRouterListener.html Field Description portMapping PortMapping The port mapping information for the listener. VirtualRouterReference ( Appears on: VirtualRouterServiceProvider ) VirtualRouterReference holds a reference to VirtualRouter.appmesh.k8s.aws Field Description namespace string (Optional) Namespace is the namespace of VirtualRouter CR. If unspecified, defaults to the referencing object\u2019s namespace name string Name is the name of VirtualRouter CR VirtualRouterServiceProvider ( Appears on: VirtualServiceProvider ) VirtualRouterServiceProvider refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_VirtualRouterServiceProvider.html Field Description virtualRouterRef VirtualRouterReference (Optional) Reference to Kubernetes VirtualRouter CR in cluster that is acting as a service provider. Exactly one of \u2018virtualRouterRef\u2019 or \u2018virtualRouterARN\u2019 must be specified. virtualRouterARN string (Optional) Amazon Resource Name to AppMesh VirtualRouter object that is acting as a service provider. Exactly one of \u2018virtualRouterRef\u2019 or \u2018virtualRouterARN\u2019 must be specified. VirtualRouterSpec ( Appears on: VirtualRouter ) VirtualRouterSpec defines the desired state of VirtualRouter refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_VirtualRouterSpec.html Field Description awsName string (Optional) AWSName is the AppMesh VirtualRouter object\u2019s name. If unspecified or empty, it defaults to be \u201c${name}_${namespace}\u201d of k8s VirtualRouter listeners []VirtualRouterListener The listeners that the virtual router is expected to receive inbound traffic from routes []Route (Optional) The routes associated with VirtualRouter meshRef MeshReference (Optional) A reference to k8s Mesh CR that this VirtualRouter belongs to. The admission controller populates it using Meshes\u2019s selector, and prevents users from setting this field. Populated by the system. Read-only. VirtualRouterStatus ( Appears on: VirtualRouter ) VirtualRouterStatus defines the observed state of VirtualRouter Field Description virtualRouterARN string (Optional) VirtualRouterARN is the AppMesh VirtualRouter object\u2019s Amazon Resource Name. routeARNs map[string]string (Optional) RouteARNs is a map of AppMesh Route objects\u2019 Amazon Resource Names, indexed by route name. conditions []VirtualRouterCondition (Optional) The current VirtualRouter status. observedGeneration int64 (Optional) The generation observed by the VirtualRouter controller. VirtualService VirtualService is the Schema for the virtualservices API Field Description metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec VirtualServiceSpec awsName string (Optional) AWSName is the AppMesh VirtualService object\u2019s name. If unspecified or empty, it defaults to be \u201c${name}.${namespace}\u201d of k8s VirtualService provider VirtualServiceProvider (Optional) The provider for virtual services. You can specify a single virtual node or virtual router. meshRef MeshReference (Optional) A reference to k8s Mesh CR that this VirtualService belongs to. The admission controller populates it using Meshes\u2019s selector, and prevents users from setting this field. Populated by the system. Read-only. status VirtualServiceStatus VirtualServiceBackend ( Appears on: Backend ) VirtualServiceBackend refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_VirtualServiceBackend.html Field Description virtualServiceRef VirtualServiceReference (Optional) Reference to Kubernetes VirtualService CR in cluster that is acting as a virtual node backend. Exactly one of \u2018virtualServiceRef\u2019 or \u2018virtualServiceARN\u2019 must be specified. virtualServiceARN string (Optional) Amazon Resource Name to AppMesh VirtualService object that is acting as a virtual node backend. Exactly one of \u2018virtualServiceRef\u2019 or \u2018virtualServiceARN\u2019 must be specified. clientPolicy ClientPolicy (Optional) A reference to an object that represents the client policy for a backend. VirtualServiceCondition ( Appears on: VirtualServiceStatus ) Field Description type VirtualServiceConditionType Type of VirtualService condition. status Kubernetes core/v1.ConditionStatus Status of the condition, one of True, False, Unknown. lastTransitionTime Kubernetes meta/v1.Time (Optional) Last time the condition transitioned from one status to another. reason string (Optional) The reason for the condition\u2019s last transition. message string (Optional) A human readable message indicating details about the transition. VirtualServiceConditionType ( string alias) ( Appears on: VirtualServiceCondition ) VirtualServiceProvider ( Appears on: VirtualServiceSpec ) VirtualServiceProvider refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_VirtualServiceProvider.html Field Description virtualNode VirtualNodeServiceProvider (Optional) The virtual node associated with a virtual service. virtualRouter VirtualRouterServiceProvider (Optional) The virtual router associated with a virtual service. VirtualServiceReference ( Appears on: GatewayRouteVirtualService , VirtualServiceBackend ) VirtualServiceReference holds a reference to VirtualService.appmesh.k8s.aws Field Description namespace string (Optional) Namespace is the namespace of VirtualService CR. If unspecified, defaults to the referencing object\u2019s namespace name string Name is the name of VirtualService CR VirtualServiceSpec ( Appears on: VirtualService ) VirtualServiceSpec defines the desired state of VirtualService refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_VirtualServiceSpec.html Field Description awsName string (Optional) AWSName is the AppMesh VirtualService object\u2019s name. If unspecified or empty, it defaults to be \u201c${name}.${namespace}\u201d of k8s VirtualService provider VirtualServiceProvider (Optional) The provider for virtual services. You can specify a single virtual node or virtual router. meshRef MeshReference (Optional) A reference to k8s Mesh CR that this VirtualService belongs to. The admission controller populates it using Meshes\u2019s selector, and prevents users from setting this field. Populated by the system. Read-only. VirtualServiceStatus ( Appears on: VirtualService ) VirtualServiceStatus defines the observed state of VirtualService Field Description virtualServiceARN string (Optional) VirtualServiceARN is the AppMesh VirtualService object\u2019s Amazon Resource Name. conditions []VirtualServiceCondition (Optional) The current VirtualService status. observedGeneration int64 (Optional) The generation observed by the VirtualService controller. WeightedTarget ( Appears on: GRPCRouteAction , HTTPRouteAction , TCPRouteAction ) WeightedTarget refers to https://docs.aws.amazon.com/app-mesh/latest/APIReference/API_WeightedTarget.html Field Description virtualNodeRef VirtualNodeReference (Optional) Reference to Kubernetes VirtualNode CR in cluster to associate with the weighted target. Exactly one of \u2018virtualNodeRef\u2019 or \u2018virtualNodeARN\u2019 must be specified. virtualNodeARN string (Optional) Amazon Resource Name to AppMesh VirtualNode object to associate with the weighted target. Exactly one of \u2018virtualNodeRef\u2019 or \u2018virtualNodeARN\u2019 must be specified. weight int64 The relative weight of the weighted target.","title":"APISpec"},{"location":"reference/backend_groups/","text":"Backend Groups \u00b6 Backend Groups are an experimental feature aimed at simplifying the process of defining backends for VirtualNodes. Enabling Backend Groups #### \u00b6 To use Backend Groups, include the flag enableBackendGroups=true in your controller deployment. BackendGroup Spec #### \u00b6 A Backend Group defines a set of VirtualService backends that can be added to VirtualNodes. Here is a sample spec with a Backend Group containing 3 VirtualServices. This group is applied to a VirtualNode. apiVersion: appmesh.k8s.aws/v1beta2 kind: BackendGroup metadata: name: color-group namespace: ${APP_NAMESPACE} spec: virtualservices: - name: green namespace: namespace-1 - name: red namespace: namespace-1 - name: yellow namespace: namespace-2 --- apiVersion: appmesh.k8s.aws/v1beta2 kind: VirtualNode metadata: name: color-node namespace: ${APP_NAMESPACE} spec: backendGroups: - name: color-group namespace: ${APP_NAMESPACE} --- VirtualNode color-node will be able to use green , red , and yellow as backends. Additionally, in the VirtualNode backendGroups field, specifying * as the Backend Group name will automatically add all VirtualServices in the specified namespace. backendGroups: - name: * namespace: color-namespace This allows any VirtualService in color-namespace to be a backend of the VirtualNode.","title":"BackendGroup CRD"},{"location":"reference/backend_groups/#backend-groups","text":"Backend Groups are an experimental feature aimed at simplifying the process of defining backends for VirtualNodes.","title":"Backend Groups"},{"location":"reference/backend_groups/#enabling-backend-groups","text":"To use Backend Groups, include the flag enableBackendGroups=true in your controller deployment.","title":"Enabling Backend Groups ####"},{"location":"reference/backend_groups/#backendgroup-spec","text":"A Backend Group defines a set of VirtualService backends that can be added to VirtualNodes. Here is a sample spec with a Backend Group containing 3 VirtualServices. This group is applied to a VirtualNode. apiVersion: appmesh.k8s.aws/v1beta2 kind: BackendGroup metadata: name: color-group namespace: ${APP_NAMESPACE} spec: virtualservices: - name: green namespace: namespace-1 - name: red namespace: namespace-1 - name: yellow namespace: namespace-2 --- apiVersion: appmesh.k8s.aws/v1beta2 kind: VirtualNode metadata: name: color-node namespace: ${APP_NAMESPACE} spec: backendGroups: - name: color-group namespace: ${APP_NAMESPACE} --- VirtualNode color-node will be able to use green , red , and yellow as backends. Additionally, in the VirtualNode backendGroups field, specifying * as the Backend Group name will automatically add all VirtualServices in the specified namespace. backendGroups: - name: * namespace: color-namespace This allows any VirtualService in color-namespace to be a backend of the VirtualNode.","title":"BackendGroup Spec ####"},{"location":"reference/injector/","text":"Sidecar installation \u00b6 In order to use AWS App Mesh in Kubernetes, pods in the mesh must be running the AWS App Mesh sidecar proxy (Envoy). The following sections describe methods for injecting sidecar/Envoy into a pod for Virtual Nodes and Virtual Gateways Envoy injection for virtual nodes \u00b6 Sidecars can be automatically added to Kubernetes pods using a mutating webhook admission controller as part of the App Mesh Kubernetes controller. App Mesh uses namespace and/or pod annotations to determine if pods in a namespace will be marked for sidecar injection. There are two ways to achieve this: appmesh.k8s.aws/sidecarInjectorWebhook: enabled : The sidecar injector will inject the sidecar into pods by default. Add the appmesh.k8s.aws/sidecarInjectorWebhook annotation with value disabled to the pod template spec to override the default and disable injection. For example: apiVersion: v1 kind: Namespace metadata: name: default-enabled labels: mesh: default-enabled appmesh.k8s.aws/sidecarInjectorWebhook: enabled --- apiVersion: apps/v1 kind: Deployment metadata: name: default-behavior // sidecar will be injected as namespace has sidecar injection enabled namespace: default-enabled spec: template: spec: containers: - name: default-behavior image: tutum/curl --- apiVersion: apps/v1 kind: Deployment metadata: name: override-default-enabled namespace: default-enabled spec: template: metadata: annotations: appmesh.k8s.aws/sidecarInjectorWebhook: disabled // this will override the default and disable inject sidecar spec: containers: - name: override-default-enabled image: tutum/curl appmesh.k8s.aws/sidecarInjectorWebhook: disabled : The sidecar injector will not inject the sidecar into pods by default. Add the appmesh.k8s.aws/sidecarInjectorWebhook annotation with value enabled to the pod template spec to override the default and enable injection. apiVersion: v1 kind: Namespace metadata: name: default-disabled labels: mesh: default-disabled appmesh.k8s.aws/sidecarInjectorWebhook: disabled --- apiVersion: apps/v1 kind: Deployment metadata: name: default-behavior // sidecar will be not injected as namespace has sidecar injection disabled namespace: default-disabled spec: template: spec: containers: - name: default-behavior image: tutum/curl --- apiVersion: apps/v1 kind: Deployment metadata: name: override-default-disabled namespace: default-disabled spec: template: metadata: annotations: appmesh.k8s.aws/sidecarInjectorWebhook: enabled // this will override the default and inject sidecar spec: containers: - name: override-default-disabled image: tutum/curl Envoy injection for virtual gateways \u00b6 AWS App Mesh supports virtual gateway resource to allow resources that are outside of your mesh to communicate to resources that are inside of your mesh. The virtual gateway represents an Envoy proxy running in the Kubernetes cluster. Unlike a virtual node, which represents Envoy running with an application, a virtual gateway represents Envoy deployed by itself. App Mesh Kubernetes controller supports injecting Envoy and virtual gateway configuration. App Mesh Kubernetes controller uses podSelector to designate Virtual Gateway membership. If you create a pod with labels matching the pod selector labels in a virtual gateway spec, the controller will inject the Envoy configuration to the pod/envoy container and override the default container image by default. Also, since a pod may contain multiple containers, the controller relies on the container name envoy to determine, which container to mutate for virtual gateway configuration. To use the controller to inject virtual gateway configuration, add podSelector to your virtual gateway, add namespaceSelector label where you need to create the virtual gateway and set the container name to envoy : apiVersion: appmesh.k8s.aws/v1beta2 kind: VirtualGateway metadata: name: ingress-gw namespace: ns spec: namespaceSelector: matchLabels: gateway: ingress-gw podSelector: matchLabels: app: ingress-gw listeners: - portMapping: port: 8088 protocol: http Add the labels in your virtual gateway pod spec: apiVersion: apps/v1 kind: Deployment metadata: name: ingress-gw namespace: ns spec: replicas: 1 selector: matchLabels: app: ingress-gw template: metadata: labels: app: ingress-gw spec: containers: - name: envoy image: <envoy-image> ports: - containerPort: 8088 Skip overriding Envoy image \u00b6 If you wish to skip the Envoy image override, you can add the annotation appmesh.k8s.aws/virtualGatewaySkipImageOverride to your pod spec. This will make sure only virtual gateway configuration is added and Envoy image url override is skipped, allowing you to use custom image version. apiVersion: apps/v1 kind: Deployment metadata: name: ingress-gw namespace: ns spec: replicas: 1 selector: matchLabels: app: ingress-gw template: metadata: annotations: appmesh.k8s.aws/virtualGatewaySkipImageOverride: enabled labels: app: ingress-gw spec: containers: - name: envoy image: <envoy-image> ports: - containerPort: 8088","title":"SidecarInjection"},{"location":"reference/injector/#sidecar-installation","text":"In order to use AWS App Mesh in Kubernetes, pods in the mesh must be running the AWS App Mesh sidecar proxy (Envoy). The following sections describe methods for injecting sidecar/Envoy into a pod for Virtual Nodes and Virtual Gateways","title":"Sidecar installation"},{"location":"reference/injector/#envoy-injection-for-virtual-nodes","text":"Sidecars can be automatically added to Kubernetes pods using a mutating webhook admission controller as part of the App Mesh Kubernetes controller. App Mesh uses namespace and/or pod annotations to determine if pods in a namespace will be marked for sidecar injection. There are two ways to achieve this: appmesh.k8s.aws/sidecarInjectorWebhook: enabled : The sidecar injector will inject the sidecar into pods by default. Add the appmesh.k8s.aws/sidecarInjectorWebhook annotation with value disabled to the pod template spec to override the default and disable injection. For example: apiVersion: v1 kind: Namespace metadata: name: default-enabled labels: mesh: default-enabled appmesh.k8s.aws/sidecarInjectorWebhook: enabled --- apiVersion: apps/v1 kind: Deployment metadata: name: default-behavior // sidecar will be injected as namespace has sidecar injection enabled namespace: default-enabled spec: template: spec: containers: - name: default-behavior image: tutum/curl --- apiVersion: apps/v1 kind: Deployment metadata: name: override-default-enabled namespace: default-enabled spec: template: metadata: annotations: appmesh.k8s.aws/sidecarInjectorWebhook: disabled // this will override the default and disable inject sidecar spec: containers: - name: override-default-enabled image: tutum/curl appmesh.k8s.aws/sidecarInjectorWebhook: disabled : The sidecar injector will not inject the sidecar into pods by default. Add the appmesh.k8s.aws/sidecarInjectorWebhook annotation with value enabled to the pod template spec to override the default and enable injection. apiVersion: v1 kind: Namespace metadata: name: default-disabled labels: mesh: default-disabled appmesh.k8s.aws/sidecarInjectorWebhook: disabled --- apiVersion: apps/v1 kind: Deployment metadata: name: default-behavior // sidecar will be not injected as namespace has sidecar injection disabled namespace: default-disabled spec: template: spec: containers: - name: default-behavior image: tutum/curl --- apiVersion: apps/v1 kind: Deployment metadata: name: override-default-disabled namespace: default-disabled spec: template: metadata: annotations: appmesh.k8s.aws/sidecarInjectorWebhook: enabled // this will override the default and inject sidecar spec: containers: - name: override-default-disabled image: tutum/curl","title":"Envoy injection for virtual nodes"},{"location":"reference/injector/#envoy-injection-for-virtual-gateways","text":"AWS App Mesh supports virtual gateway resource to allow resources that are outside of your mesh to communicate to resources that are inside of your mesh. The virtual gateway represents an Envoy proxy running in the Kubernetes cluster. Unlike a virtual node, which represents Envoy running with an application, a virtual gateway represents Envoy deployed by itself. App Mesh Kubernetes controller supports injecting Envoy and virtual gateway configuration. App Mesh Kubernetes controller uses podSelector to designate Virtual Gateway membership. If you create a pod with labels matching the pod selector labels in a virtual gateway spec, the controller will inject the Envoy configuration to the pod/envoy container and override the default container image by default. Also, since a pod may contain multiple containers, the controller relies on the container name envoy to determine, which container to mutate for virtual gateway configuration. To use the controller to inject virtual gateway configuration, add podSelector to your virtual gateway, add namespaceSelector label where you need to create the virtual gateway and set the container name to envoy : apiVersion: appmesh.k8s.aws/v1beta2 kind: VirtualGateway metadata: name: ingress-gw namespace: ns spec: namespaceSelector: matchLabels: gateway: ingress-gw podSelector: matchLabels: app: ingress-gw listeners: - portMapping: port: 8088 protocol: http Add the labels in your virtual gateway pod spec: apiVersion: apps/v1 kind: Deployment metadata: name: ingress-gw namespace: ns spec: replicas: 1 selector: matchLabels: app: ingress-gw template: metadata: labels: app: ingress-gw spec: containers: - name: envoy image: <envoy-image> ports: - containerPort: 8088","title":"Envoy injection for virtual gateways"},{"location":"reference/injector/#skip-overriding-envoy-image","text":"If you wish to skip the Envoy image override, you can add the annotation appmesh.k8s.aws/virtualGatewaySkipImageOverride to your pod spec. This will make sure only virtual gateway configuration is added and Envoy image url override is skipped, allowing you to use custom image version. apiVersion: apps/v1 kind: Deployment metadata: name: ingress-gw namespace: ns spec: replicas: 1 selector: matchLabels: app: ingress-gw template: metadata: annotations: appmesh.k8s.aws/virtualGatewaySkipImageOverride: enabled labels: app: ingress-gw spec: containers: - name: envoy image: <envoy-image> ports: - containerPort: 8088","title":"Skip overriding Envoy image"},{"location":"reference/vgw/","text":"GatewayRoute to VirtualGateway Association via (Yaml Spec) \u00b6 A VirtualGateway can select GatewayRoute using following selectors namespaceSelector #### \u00b6 VirtualGateway must specify namespaceSelector to associate GatewayRoutes belonging to a particular namespace. An empty namespaceSelector would target GatewayRoutes in all namespaces. While nil or not specifying any namespace selector would not select any GatewayRoutes. gatewayRouteSelector #### \u00b6 VirtualGateway can additionally specify gatewayRouteSelector to select subset of GatewayRoutes in a given namespace. An empty or not specifying this field (nil) will select all GatewayRoutes in a given namespace. If specified then it will select only those GatewayRoutes which have the matching labels. Here is a sample spec with 1 VirtualGateway and 2 GatewayRoutes. Here VirtualGateway specified a gatewayRouteSelector, based on which only one of the GatewayRoutes get selected. apiVersion: appmesh.k8s.aws/v1beta2 kind: VirtualGateway metadata: name: ingress-gw namespace: ${APP_NAMESPACE} spec: namespaceSelector: matchLabels: gateway: ingress-gw gatewayRouteSelector: matchLabels: gateway: ingress-gw podSelector: matchLabels: app: ingress-gw listeners: - portMapping: port: 8088 protocol: http --- apiVersion: appmesh.k8s.aws/v1beta2 kind: GatewayRoute metadata: name: gateway-route-headers namespace: ${APP_NAMESPACE} spec: httpRoute: match: prefix: \"/headers\" action: target: virtualService: virtualServiceRef: name: color-headers --- apiVersion: appmesh.k8s.aws/v1beta2 kind: GatewayRoute metadata: name: gateway-route-paths namespace: ${APP_NAMESPACE} labels: gateway: ingress-gw spec: httpRoute: match: prefix: \"/paths\" action: target: virtualService: virtualServiceRef: name: color-paths ---- Since the GatewayRoute: gateway-route-headers doesn't have any matching VirtualGateway, customers will see following error message failed to find matching virtualGateway for gatewayRoute: gateway-route-headers, expecting 1 but found 0 The above error message is to only notify the user that the GatewayRoute in the error message has not been associated with any VirtualGateway. So the user should either add matching gatewayRouteSelector to the unmatched gatewayRoute or completely remove the gatewayRouteSelector so that the VirtualGateway ignores this field and uses only the namespaceSelector.","title":"VirtualGateway CRD"},{"location":"reference/vgw/#gatewayroute-to-virtualgateway-association-via-yaml-spec","text":"A VirtualGateway can select GatewayRoute using following selectors","title":"GatewayRoute to VirtualGateway Association via (Yaml Spec)"},{"location":"reference/vgw/#namespaceselector","text":"VirtualGateway must specify namespaceSelector to associate GatewayRoutes belonging to a particular namespace. An empty namespaceSelector would target GatewayRoutes in all namespaces. While nil or not specifying any namespace selector would not select any GatewayRoutes.","title":"namespaceSelector ####"},{"location":"reference/vgw/#gatewayrouteselector","text":"VirtualGateway can additionally specify gatewayRouteSelector to select subset of GatewayRoutes in a given namespace. An empty or not specifying this field (nil) will select all GatewayRoutes in a given namespace. If specified then it will select only those GatewayRoutes which have the matching labels. Here is a sample spec with 1 VirtualGateway and 2 GatewayRoutes. Here VirtualGateway specified a gatewayRouteSelector, based on which only one of the GatewayRoutes get selected. apiVersion: appmesh.k8s.aws/v1beta2 kind: VirtualGateway metadata: name: ingress-gw namespace: ${APP_NAMESPACE} spec: namespaceSelector: matchLabels: gateway: ingress-gw gatewayRouteSelector: matchLabels: gateway: ingress-gw podSelector: matchLabels: app: ingress-gw listeners: - portMapping: port: 8088 protocol: http --- apiVersion: appmesh.k8s.aws/v1beta2 kind: GatewayRoute metadata: name: gateway-route-headers namespace: ${APP_NAMESPACE} spec: httpRoute: match: prefix: \"/headers\" action: target: virtualService: virtualServiceRef: name: color-headers --- apiVersion: appmesh.k8s.aws/v1beta2 kind: GatewayRoute metadata: name: gateway-route-paths namespace: ${APP_NAMESPACE} labels: gateway: ingress-gw spec: httpRoute: match: prefix: \"/paths\" action: target: virtualService: virtualServiceRef: name: color-paths ---- Since the GatewayRoute: gateway-route-headers doesn't have any matching VirtualGateway, customers will see following error message failed to find matching virtualGateway for gatewayRoute: gateway-route-headers, expecting 1 but found 0 The above error message is to only notify the user that the GatewayRoute in the error message has not been associated with any VirtualGateway. So the user should either add matching gatewayRouteSelector to the unmatched gatewayRoute or completely remove the gatewayRouteSelector so that the VirtualGateway ignores this field and uses only the namespaceSelector.","title":"gatewayRouteSelector ####"},{"location":"tutorials/walkthroughs/","text":"App Mesh EKS Walkthroughs \u00b6 howto-k8s-alb : This example shows how to use ALB Ingress Controller with targets registered as virtual-nodes under App Mesh. howto-k8s-cloudmap : This example shows how Kubernetes deployments can use AWS CloudMap for service-discovery when using App Mesh. howto-k8s-fargate : This example shows how to use AppMesh with EKS on Fargate. howto-k8s-grpc :This example shows how to manage gRPC routes in App Mesh using Kubernetes deployments. howto-k8s-http-headers : This example shows how http routes can use headers for matching incoming requests. howto-k8s-http2 : This example shows how to manage HTTP/2 routes in App Mesh using Kubernetes deployments howto-k8s-retry-policy : This example shows how retry-policies can be used to for Kubernetes applications within the context of App Mesh. howto-k8s-ingress-gateway : This example shows how to use App Mesh Virtual Gateways for ingress connectivity towards Kubernetes applications. howto-k8s-tls-file-based : This example shows how to enable TLS encryption between applications in App Mesh using X.509 certificates and mount secrets on Envoy using the injector howto-k8s-outlier-detection : This example shows how to use outlier detection capabilities in AWS App Mesh with EKS howto-k8s-connection-pools : This example shows how to use circuit breaking/connection pool configuration capabilities in AWS App Mesh with EKS howto-k8s-cross-cluster : This example shows how to use App Mesh across kubernetes clusters","title":"Walkthroughs"},{"location":"tutorials/walkthroughs/#app-mesh-eks-walkthroughs","text":"howto-k8s-alb : This example shows how to use ALB Ingress Controller with targets registered as virtual-nodes under App Mesh. howto-k8s-cloudmap : This example shows how Kubernetes deployments can use AWS CloudMap for service-discovery when using App Mesh. howto-k8s-fargate : This example shows how to use AppMesh with EKS on Fargate. howto-k8s-grpc :This example shows how to manage gRPC routes in App Mesh using Kubernetes deployments. howto-k8s-http-headers : This example shows how http routes can use headers for matching incoming requests. howto-k8s-http2 : This example shows how to manage HTTP/2 routes in App Mesh using Kubernetes deployments howto-k8s-retry-policy : This example shows how retry-policies can be used to for Kubernetes applications within the context of App Mesh. howto-k8s-ingress-gateway : This example shows how to use App Mesh Virtual Gateways for ingress connectivity towards Kubernetes applications. howto-k8s-tls-file-based : This example shows how to enable TLS encryption between applications in App Mesh using X.509 certificates and mount secrets on Envoy using the injector howto-k8s-outlier-detection : This example shows how to use outlier detection capabilities in AWS App Mesh with EKS howto-k8s-connection-pools : This example shows how to use circuit breaking/connection pool configuration capabilities in AWS App Mesh with EKS howto-k8s-cross-cluster : This example shows how to use App Mesh across kubernetes clusters","title":"App Mesh EKS Walkthroughs"}]}